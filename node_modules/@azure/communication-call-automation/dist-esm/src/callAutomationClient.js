import { __rest } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { isTokenCredential } from "@azure/core-auth";
import { parseClientArguments, isKeyCredential, createCommunicationAuthPolicy, } from "@azure/communication-common";
import { logger } from "./models/logger";
import { CallAutomationApiClient, } from "./generated/src";
import { CallConnection } from "./callConnection";
import { CallRecording } from "./callRecording";
import { communicationIdentifierConverter, communicationIdentifierModelConverter, communicationUserIdentifierConverter, communicationUserIdentifierModelConverter, phoneNumberIdentifierConverter, PhoneNumberIdentifierModelConverter, } from "./utli/converters";
import { v4 as uuidv4 } from "uuid";
/**
 * Checks whether the type of a value is CallAutomationClientOptions or not.
 *
 * @param options - The value being checked.
 */
const isCallAutomationClientOptions = (options) => !!options && !isTokenCredential(options) && !isKeyCredential(options);
/**
 * A CallAutomationClient represents a Client to the Azure Communication CallAutomation service.
 */
export class CallAutomationClient {
    constructor(connectionStringOrUrl, credentialOrOptions, maybeOptions = {}) {
        const options = isCallAutomationClientOptions(credentialOrOptions)
            ? credentialOrOptions
            : maybeOptions;
        if (!(options === null || options === void 0 ? void 0 : options.userAgentOptions)) {
            options.userAgentOptions = {};
        }
        this.internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        const { url, credential } = parseClientArguments(connectionStringOrUrl, credentialOrOptions);
        const authPolicy = createCommunicationAuthPolicy(credential);
        this.credential = credential;
        this.callAutomationApiClient = new CallAutomationApiClient(url, this.internalPipelineOptions);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.sourceIdentity = communicationUserIdentifierModelConverter(options.sourceIdentity);
    }
    /**
     * Initializes a new instance of CallConnection.
     * @param callConnectionId - The CallConnection id for the CallConnection instance. (ex: 421CONTOSO-cRD6-4RDc-a078-99dRANDOMf).
     */
    getCallConnection(callConnectionId) {
        return new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
    }
    /**
     * Initializes a new instance of CallRecording.
     */
    getCallRecording() {
        return new CallRecording(this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
    }
    /**
     * Get Source Identity that is used for create and answer call
     */
    getSourceIdentity() {
        return communicationUserIdentifierConverter(this.sourceIdentity);
    }
    async createCallInternal(request, options) {
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuidv4() });
        const _a = await this.callAutomationApiClient.createCall(request, optionsInternal), { callConnectionId, answeredBy, targets, sourceCallerIdNumber, source } = _a, result = __rest(_a, ["callConnectionId", "answeredBy", "targets", "sourceCallerIdNumber", "source"]);
        if (callConnectionId) {
            const callConnectionPropertiesDto = Object.assign(Object.assign({}, result), { callConnectionId: callConnectionId, source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((returnedTarget) => communicationIdentifierConverter(returnedTarget)), sourceCallerIdNumber: sourceCallerIdNumber
                    ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                    : undefined });
            const callConnection = new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
            const createCallResult = {
                callConnectionProperties: callConnectionPropertiesDto,
                callConnection: callConnection,
            };
            return createCallResult;
        }
        throw "callConnectionProperties / callConnectionId is missing in createCall result";
    }
    /**
     * Create an outgoing call from source to a target identity.
     * @param targetParticipant - A single target.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains createCallConnection api options.
     */
    async createCall(targetParticipant, callbackUrl, options = {}) {
        const request = {
            source: this.sourceIdentity,
            targets: [communicationIdentifierModelConverter(targetParticipant.targetParticipant)],
            callbackUri: callbackUrl,
            operationContext: options.operationContext,
            callIntelligenceOptions: options.callIntelligenceOptions,
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(targetParticipant.sourceCallIdNumber),
            sourceDisplayName: targetParticipant.sourceDisplayName,
        };
        return this.createCallInternal(request, options);
    }
    /**
     * Create an outgoing call from source to a group of targets identities.
     * @param targetParticipants - A group of targets identities.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains createCallConnection api options.
     */
    async createGroupCall(targetParticipants, callbackUrl, options = {}) {
        const request = {
            source: this.sourceIdentity,
            targets: targetParticipants.map((target) => communicationIdentifierModelConverter(target)),
            callbackUri: callbackUrl,
            operationContext: options.operationContext,
            callIntelligenceOptions: options.callIntelligenceOptions,
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(options.sourceCallIdNumber),
            sourceDisplayName: options.sourceDisplayName,
        };
        return this.createCallInternal(request, options);
    }
    /**
     * Answer the call.
     * @param incomingCallContext - The context associated with the call.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains answerCall api options.
     */
    async answerCall(incomingCallContext, callbackUrl, options = {}) {
        const { callIntelligenceOptions, operationContext } = options, operationOptions = __rest(options, ["callIntelligenceOptions", "operationContext"]);
        const request = {
            incomingCallContext,
            callIntelligenceOptions,
            operationContext,
            callbackUri: callbackUrl,
            answeredBy: this.sourceIdentity,
        };
        const optionsInternal = Object.assign(Object.assign({}, operationOptions), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuidv4() });
        const _a = await this.callAutomationApiClient.answerCall(request, optionsInternal), { callConnectionId, targets, sourceCallerIdNumber, answeredBy, source } = _a, result = __rest(_a, ["callConnectionId", "targets", "sourceCallerIdNumber", "answeredBy", "source"]);
        if (callConnectionId) {
            const callConnectionProperties = Object.assign(Object.assign({}, result), { callConnectionId: callConnectionId, source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((target) => communicationIdentifierConverter(target)), sourceCallerIdNumber: sourceCallerIdNumber
                    ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                    : undefined });
            const callConnection = new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
            const answerCallResult = {
                callConnectionProperties: callConnectionProperties,
                callConnection: callConnection,
            };
            return answerCallResult;
        }
        throw "callConnectionProperties / callConnectionId is missing in createCall result";
    }
    /**
     * Redirect the call.
     *
     * @param incomingCallContext - The context associated with the call.
     * @param targetParticipant - The target identity to redirect the call to.
     * @param options - Additional request options contains redirectCall api options.
     */
    async redirectCall(incomingCallContext, targetParticipant, options = {}) {
        const request = {
            incomingCallContext: incomingCallContext,
            target: communicationIdentifierModelConverter(targetParticipant.targetParticipant),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuidv4() });
        return this.callAutomationApiClient.redirectCall(request, optionsInternal);
    }
    /**
     * Reject the call.
     *
     * @param incomingCallContext - The context associated with the call.
     * @param options - Additional request options contains rejectCall api options.
     */
    async rejectCall(incomingCallContext, options = {}) {
        const request = {
            incomingCallContext: incomingCallContext,
            callRejectReason: options.callRejectReason,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuidv4() });
        return this.callAutomationApiClient.rejectCall(request, optionsInternal);
    }
}
//# sourceMappingURL=callAutomationClient.js.map