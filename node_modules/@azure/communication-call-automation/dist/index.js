'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreAuth = require('@azure/core-auth');
var communicationCommon = require('@azure/communication-common');
var logger$1 = require('@azure/logger');
var uuid = require('uuid');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var fs = require('fs');
var coreUtil = require('@azure/core-util');
var crypto = require('crypto');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-call-automation");

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CommunicationIdentifierModelKind} that the service accepts. */
var KnownCommunicationIdentifierModelKind;
(function (KnownCommunicationIdentifierModelKind) {
    /** Unknown */
    KnownCommunicationIdentifierModelKind["Unknown"] = "unknown";
    /** CommunicationUser */
    KnownCommunicationIdentifierModelKind["CommunicationUser"] = "communicationUser";
    /** PhoneNumber */
    KnownCommunicationIdentifierModelKind["PhoneNumber"] = "phoneNumber";
    /** MicrosoftTeamsUser */
    KnownCommunicationIdentifierModelKind["MicrosoftTeamsUser"] = "microsoftTeamsUser";
    /** MicrosoftTeamsApp */
    KnownCommunicationIdentifierModelKind["MicrosoftTeamsApp"] = "microsoftTeamsApp";
})(KnownCommunicationIdentifierModelKind || (KnownCommunicationIdentifierModelKind = {}));
/** Known values of {@link CommunicationCloudEnvironmentModel} that the service accepts. */
var KnownCommunicationCloudEnvironmentModel;
(function (KnownCommunicationCloudEnvironmentModel) {
    /** Public */
    KnownCommunicationCloudEnvironmentModel["Public"] = "public";
    /** Dod */
    KnownCommunicationCloudEnvironmentModel["Dod"] = "dod";
    /** Gcch */
    KnownCommunicationCloudEnvironmentModel["Gcch"] = "gcch";
})(KnownCommunicationCloudEnvironmentModel || (KnownCommunicationCloudEnvironmentModel = {}));
/** Known values of {@link CallConnectionStateModel} that the service accepts. */
var KnownCallConnectionStateModel;
(function (KnownCallConnectionStateModel) {
    /** Unknown */
    KnownCallConnectionStateModel["Unknown"] = "unknown";
    /** Connecting */
    KnownCallConnectionStateModel["Connecting"] = "connecting";
    /** Connected */
    KnownCallConnectionStateModel["Connected"] = "connected";
    /** Transferring */
    KnownCallConnectionStateModel["Transferring"] = "transferring";
    /** TransferAccepted */
    KnownCallConnectionStateModel["TransferAccepted"] = "transferAccepted";
    /** Disconnecting */
    KnownCallConnectionStateModel["Disconnecting"] = "disconnecting";
    /** Disconnected */
    KnownCallConnectionStateModel["Disconnected"] = "disconnected";
})(KnownCallConnectionStateModel || (KnownCallConnectionStateModel = {}));
/** Known values of {@link CallRejectReason} that the service accepts. */
exports.KnownCallRejectReason = void 0;
(function (KnownCallRejectReason) {
    /** None */
    KnownCallRejectReason["None"] = "none";
    /** Busy */
    KnownCallRejectReason["Busy"] = "busy";
    /** Forbidden */
    KnownCallRejectReason["Forbidden"] = "forbidden";
})(exports.KnownCallRejectReason || (exports.KnownCallRejectReason = {}));
/** Known values of {@link PlaySourceType} that the service accepts. */
var KnownPlaySourceType;
(function (KnownPlaySourceType) {
    /** File */
    KnownPlaySourceType["File"] = "file";
    /** Text */
    KnownPlaySourceType["Text"] = "text";
    /** Ssml */
    KnownPlaySourceType["Ssml"] = "ssml";
})(KnownPlaySourceType || (KnownPlaySourceType = {}));
/** Known values of {@link VoiceKind} that the service accepts. */
var KnownVoiceKind;
(function (KnownVoiceKind) {
    /** Male */
    KnownVoiceKind["Male"] = "male";
    /** Female */
    KnownVoiceKind["Female"] = "female";
})(KnownVoiceKind || (KnownVoiceKind = {}));
/** Known values of {@link RecognizeInputType} that the service accepts. */
var KnownRecognizeInputType;
(function (KnownRecognizeInputType) {
    /** Dtmf */
    KnownRecognizeInputType["Dtmf"] = "dtmf";
    /** Speech */
    KnownRecognizeInputType["Speech"] = "speech";
    /** SpeechOrDtmf */
    KnownRecognizeInputType["SpeechOrDtmf"] = "speechOrDtmf";
    /** Choices */
    KnownRecognizeInputType["Choices"] = "choices";
})(KnownRecognizeInputType || (KnownRecognizeInputType = {}));
/** Known values of {@link Tone} that the service accepts. */
var KnownTone;
(function (KnownTone) {
    /** Zero */
    KnownTone["Zero"] = "zero";
    /** One */
    KnownTone["One"] = "one";
    /** Two */
    KnownTone["Two"] = "two";
    /** Three */
    KnownTone["Three"] = "three";
    /** Four */
    KnownTone["Four"] = "four";
    /** Five */
    KnownTone["Five"] = "five";
    /** Six */
    KnownTone["Six"] = "six";
    /** Seven */
    KnownTone["Seven"] = "seven";
    /** Eight */
    KnownTone["Eight"] = "eight";
    /** Nine */
    KnownTone["Nine"] = "nine";
    /** A */
    KnownTone["A"] = "a";
    /** B */
    KnownTone["B"] = "b";
    /** C */
    KnownTone["C"] = "c";
    /** D */
    KnownTone["D"] = "d";
    /** Pound */
    KnownTone["Pound"] = "pound";
    /** Asterisk */
    KnownTone["Asterisk"] = "asterisk";
})(KnownTone || (KnownTone = {}));
/** Known values of {@link CallLocatorKind} that the service accepts. */
var KnownCallLocatorKind;
(function (KnownCallLocatorKind) {
    /** GroupCallLocator */
    KnownCallLocatorKind["GroupCallLocator"] = "groupCallLocator";
    /** ServerCallLocator */
    KnownCallLocatorKind["ServerCallLocator"] = "serverCallLocator";
})(KnownCallLocatorKind || (KnownCallLocatorKind = {}));
/** Known values of {@link RecordingContentType} that the service accepts. */
var KnownRecordingContentType;
(function (KnownRecordingContentType) {
    /** Audio */
    KnownRecordingContentType["Audio"] = "audio";
    /** AudioVideo */
    KnownRecordingContentType["AudioVideo"] = "audioVideo";
})(KnownRecordingContentType || (KnownRecordingContentType = {}));
/** Known values of {@link RecordingChannelType} that the service accepts. */
var KnownRecordingChannelType;
(function (KnownRecordingChannelType) {
    /** Mixed */
    KnownRecordingChannelType["Mixed"] = "mixed";
    /** Unmixed */
    KnownRecordingChannelType["Unmixed"] = "unmixed";
})(KnownRecordingChannelType || (KnownRecordingChannelType = {}));
/** Known values of {@link RecordingFormatType} that the service accepts. */
var KnownRecordingFormatType;
(function (KnownRecordingFormatType) {
    /** Wav */
    KnownRecordingFormatType["Wav"] = "wav";
    /** Mp3 */
    KnownRecordingFormatType["Mp3"] = "mp3";
    /** Mp4 */
    KnownRecordingFormatType["Mp4"] = "mp4";
})(KnownRecordingFormatType || (KnownRecordingFormatType = {}));
/** Known values of {@link RecordingStorageKind} that the service accepts. */
var KnownRecordingStorageKind;
(function (KnownRecordingStorageKind) {
    /** Storage managed by Azure Communication Services */
    KnownRecordingStorageKind["AzureCommunicationServices"] = "AzureCommunicationServices";
    /** Storage managed by provided Azure blob */
    KnownRecordingStorageKind["AzureBlobStorage"] = "AzureBlobStorage";
})(KnownRecordingStorageKind || (KnownRecordingStorageKind = {}));
/** Known values of {@link RecordingState} that the service accepts. */
var KnownRecordingState;
(function (KnownRecordingState) {
    /** Active */
    KnownRecordingState["Active"] = "active";
    /** Inactive */
    KnownRecordingState["Inactive"] = "inactive";
})(KnownRecordingState || (KnownRecordingState = {}));
/** Known values of {@link RecordingKind} that the service accepts. */
var KnownRecordingKind;
(function (KnownRecordingKind) {
    /** Recording initiated by Azure Communication Services */
    KnownRecordingKind["AzureCommunicationServices"] = "AzureCommunicationServices";
    /** Recording initiated by Teams user */
    KnownRecordingKind["Teams"] = "Teams";
    /** Recording initiated by Teams compliance policy */
    KnownRecordingKind["TeamsCompliance"] = "TeamsCompliance";
})(KnownRecordingKind || (KnownRecordingKind = {}));
/** Known values of {@link RecognitionType} that the service accepts. */
var KnownRecognitionType;
(function (KnownRecognitionType) {
    /** Dtmf */
    KnownRecognitionType["Dtmf"] = "dtmf";
    /** Speech */
    KnownRecognitionType["Speech"] = "speech";
    /** Choices */
    KnownRecognitionType["Choices"] = "choices";
})(KnownRecognitionType || (KnownRecognitionType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CreateCallRequest = {
    type: {
        name: "Composite",
        className: "CreateCallRequest",
        modelProperties: {
            targets: {
                serializedName: "targets",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationIdentifierModel",
                        },
                    },
                },
            },
            sourceCallerIdNumber: {
                serializedName: "sourceCallerIdNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel",
                },
            },
            sourceDisplayName: {
                serializedName: "sourceDisplayName",
                type: {
                    name: "String",
                },
            },
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            callbackUri: {
                serializedName: "callbackUri",
                required: true,
                type: {
                    name: "String",
                },
            },
            callIntelligenceOptions: {
                serializedName: "callIntelligenceOptions",
                type: {
                    name: "Composite",
                    className: "CallIntelligenceOptionsInternal",
                },
            },
        },
    },
};
const CommunicationIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationIdentifierModel",
        modelProperties: {
            kind: {
                serializedName: "kind",
                type: {
                    name: "String",
                },
            },
            rawId: {
                serializedName: "rawId",
                type: {
                    name: "String",
                },
            },
            communicationUser: {
                serializedName: "communicationUser",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel",
                },
            },
            phoneNumber: {
                serializedName: "phoneNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel",
                },
            },
            microsoftTeamsUser: {
                serializedName: "microsoftTeamsUser",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsUserIdentifierModel",
                },
            },
            microsoftTeamsApp: {
                serializedName: "microsoftTeamsApp",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsAppIdentifierModel",
                },
            },
        },
    },
};
const CommunicationUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationUserIdentifierModel",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PhoneNumberIdentifierModel = {
    type: {
        name: "Composite",
        className: "PhoneNumberIdentifierModel",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MicrosoftTeamsUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsUserIdentifierModel",
        modelProperties: {
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String",
                },
            },
            isAnonymous: {
                serializedName: "isAnonymous",
                type: {
                    name: "Boolean",
                },
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MicrosoftTeamsAppIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsAppIdentifierModel",
        modelProperties: {
            appId: {
                serializedName: "appId",
                required: true,
                type: {
                    name: "String",
                },
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CallIntelligenceOptionsInternal = {
    type: {
        name: "Composite",
        className: "CallIntelligenceOptionsInternal",
        modelProperties: {
            cognitiveServicesEndpoint: {
                serializedName: "cognitiveServicesEndpoint",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CallConnectionPropertiesInternal = {
    type: {
        name: "Composite",
        className: "CallConnectionPropertiesInternal",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            targets: {
                serializedName: "targets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationIdentifierModel",
                        },
                    },
                },
            },
            callConnectionState: {
                serializedName: "callConnectionState",
                type: {
                    name: "String",
                },
            },
            callbackUri: {
                serializedName: "callbackUri",
                type: {
                    name: "String",
                },
            },
            sourceCallerIdNumber: {
                serializedName: "sourceCallerIdNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel",
                },
            },
            sourceDisplayName: {
                serializedName: "sourceDisplayName",
                type: {
                    name: "String",
                },
            },
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            answeredBy: {
                serializedName: "answeredBy",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel",
                },
            },
        },
    },
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CommunicationError",
                },
            },
        },
    },
};
const CommunicationError = {
    type: {
        name: "Composite",
        className: "CommunicationError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationError",
                        },
                    },
                },
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "CommunicationError",
                },
            },
        },
    },
};
const AnswerCallRequest = {
    type: {
        name: "Composite",
        className: "AnswerCallRequest",
        modelProperties: {
            incomingCallContext: {
                serializedName: "incomingCallContext",
                required: true,
                type: {
                    name: "String",
                },
            },
            callbackUri: {
                serializedName: "callbackUri",
                required: true,
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            callIntelligenceOptions: {
                serializedName: "callIntelligenceOptions",
                type: {
                    name: "Composite",
                    className: "CallIntelligenceOptionsInternal",
                },
            },
            answeredBy: {
                serializedName: "answeredBy",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel",
                },
            },
        },
    },
};
const RedirectCallRequest = {
    type: {
        name: "Composite",
        className: "RedirectCallRequest",
        modelProperties: {
            incomingCallContext: {
                serializedName: "incomingCallContext",
                required: true,
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const RejectCallRequest = {
    type: {
        name: "Composite",
        className: "RejectCallRequest",
        modelProperties: {
            incomingCallContext: {
                serializedName: "incomingCallContext",
                required: true,
                type: {
                    name: "String",
                },
            },
            callRejectReason: {
                serializedName: "callRejectReason",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TransferToParticipantRequest = {
    type: {
        name: "Composite",
        className: "TransferToParticipantRequest",
        modelProperties: {
            targetParticipant: {
                serializedName: "targetParticipant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            transferee: {
                serializedName: "transferee",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
            customCallingContext: {
                serializedName: "customCallingContext",
                type: {
                    name: "Composite",
                    className: "CustomCallingContextInternal",
                },
            },
        },
    },
};
const CustomCallingContextInternal = {
    type: {
        name: "Composite",
        className: "CustomCallingContextInternal",
        modelProperties: {
            voipHeaders: {
                serializedName: "voipHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            sipHeaders: {
                serializedName: "sipHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const TransferCallResponse = {
    type: {
        name: "Composite",
        className: "TransferCallResponse",
        modelProperties: {
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PlayRequest = {
    type: {
        name: "Composite",
        className: "PlayRequest",
        modelProperties: {
            playSources: {
                serializedName: "playSources",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PlaySourceInternal",
                        },
                    },
                },
            },
            playTo: {
                serializedName: "playTo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationIdentifierModel",
                        },
                    },
                },
            },
            playOptions: {
                serializedName: "playOptions",
                type: {
                    name: "Composite",
                    className: "PlayOptionsInternal",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PlaySourceInternal = {
    type: {
        name: "Composite",
        className: "PlaySourceInternal",
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String",
                },
            },
            playSourceCacheId: {
                serializedName: "playSourceCacheId",
                type: {
                    name: "String",
                },
            },
            file: {
                serializedName: "file",
                type: {
                    name: "Composite",
                    className: "FileSourceInternal",
                },
            },
            text: {
                serializedName: "text",
                type: {
                    name: "Composite",
                    className: "TextSourceInternal",
                },
            },
            ssml: {
                serializedName: "ssml",
                type: {
                    name: "Composite",
                    className: "SsmlSourceInternal",
                },
            },
        },
    },
};
const FileSourceInternal = {
    type: {
        name: "Composite",
        className: "FileSourceInternal",
        modelProperties: {
            uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TextSourceInternal = {
    type: {
        name: "Composite",
        className: "TextSourceInternal",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String",
                },
            },
            sourceLocale: {
                serializedName: "sourceLocale",
                type: {
                    name: "String",
                },
            },
            voiceKind: {
                serializedName: "voiceKind",
                type: {
                    name: "String",
                },
            },
            voiceName: {
                serializedName: "voiceName",
                type: {
                    name: "String",
                },
            },
            customVoiceEndpointId: {
                serializedName: "customVoiceEndpointId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SsmlSourceInternal = {
    type: {
        name: "Composite",
        className: "SsmlSourceInternal",
        modelProperties: {
            ssmlText: {
                serializedName: "ssmlText",
                required: true,
                type: {
                    name: "String",
                },
            },
            customVoiceEndpointId: {
                serializedName: "customVoiceEndpointId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PlayOptionsInternal = {
    type: {
        name: "Composite",
        className: "PlayOptionsInternal",
        modelProperties: {
            loop: {
                serializedName: "loop",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const RecognizeRequest = {
    type: {
        name: "Composite",
        className: "RecognizeRequest",
        modelProperties: {
            recognizeInputType: {
                serializedName: "recognizeInputType",
                required: true,
                type: {
                    name: "String",
                },
            },
            playPrompt: {
                serializedName: "playPrompt",
                type: {
                    name: "Composite",
                    className: "PlaySourceInternal",
                },
            },
            interruptCallMediaOperation: {
                serializedName: "interruptCallMediaOperation",
                type: {
                    name: "Boolean",
                },
            },
            recognizeOptions: {
                serializedName: "recognizeOptions",
                type: {
                    name: "Composite",
                    className: "RecognizeOptions",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RecognizeOptions = {
    type: {
        name: "Composite",
        className: "RecognizeOptions",
        modelProperties: {
            interruptPrompt: {
                serializedName: "interruptPrompt",
                type: {
                    name: "Boolean",
                },
            },
            initialSilenceTimeoutInSeconds: {
                constraints: {
                    InclusiveMaximum: 300,
                    InclusiveMinimum: 0,
                },
                serializedName: "initialSilenceTimeoutInSeconds",
                type: {
                    name: "Number",
                },
            },
            targetParticipant: {
                serializedName: "targetParticipant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            speechLanguage: {
                serializedName: "speechLanguage",
                type: {
                    name: "String",
                },
            },
            speechRecognitionModelEndpointId: {
                serializedName: "speechRecognitionModelEndpointId",
                type: {
                    name: "String",
                },
            },
            dtmfOptions: {
                serializedName: "dtmfOptions",
                type: {
                    name: "Composite",
                    className: "DtmfOptions",
                },
            },
            choices: {
                serializedName: "choices",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Choice",
                        },
                    },
                },
            },
            speechOptions: {
                serializedName: "speechOptions",
                type: {
                    name: "Composite",
                    className: "SpeechOptions",
                },
            },
        },
    },
};
const DtmfOptions = {
    type: {
        name: "Composite",
        className: "DtmfOptions",
        modelProperties: {
            interToneTimeoutInSeconds: {
                constraints: {
                    InclusiveMaximum: 60,
                    InclusiveMinimum: 1,
                },
                serializedName: "interToneTimeoutInSeconds",
                type: {
                    name: "Number",
                },
            },
            maxTonesToCollect: {
                serializedName: "maxTonesToCollect",
                type: {
                    name: "Number",
                },
            },
            stopTones: {
                serializedName: "stopTones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const Choice = {
    type: {
        name: "Composite",
        className: "Choice",
        modelProperties: {
            label: {
                serializedName: "label",
                required: true,
                type: {
                    name: "String",
                },
            },
            phrases: {
                serializedName: "phrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            tone: {
                serializedName: "tone",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SpeechOptions = {
    type: {
        name: "Composite",
        className: "SpeechOptions",
        modelProperties: {
            endSilenceTimeoutInMs: {
                serializedName: "endSilenceTimeoutInMs",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ContinuousDtmfRecognitionRequest = {
    type: {
        name: "Composite",
        className: "ContinuousDtmfRecognitionRequest",
        modelProperties: {
            targetParticipant: {
                serializedName: "targetParticipant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SendDtmfTonesRequest = {
    type: {
        name: "Composite",
        className: "SendDtmfTonesRequest",
        modelProperties: {
            tones: {
                serializedName: "tones",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            targetParticipant: {
                serializedName: "targetParticipant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SendDtmfTonesResult = {
    type: {
        name: "Composite",
        className: "SendDtmfTonesResult",
        modelProperties: {
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GetParticipantsResponse = {
    type: {
        name: "Composite",
        className: "GetParticipantsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CallParticipantInternal",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CallParticipantInternal = {
    type: {
        name: "Composite",
        className: "CallParticipantInternal",
        modelProperties: {
            identifier: {
                serializedName: "identifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            isMuted: {
                serializedName: "isMuted",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AddParticipantRequest = {
    type: {
        name: "Composite",
        className: "AddParticipantRequest",
        modelProperties: {
            sourceCallerIdNumber: {
                serializedName: "sourceCallerIdNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel",
                },
            },
            sourceDisplayName: {
                serializedName: "sourceDisplayName",
                type: {
                    name: "String",
                },
            },
            participantToAdd: {
                serializedName: "participantToAdd",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            invitationTimeoutInSeconds: {
                constraints: {
                    InclusiveMaximum: 180,
                    InclusiveMinimum: 0,
                },
                serializedName: "invitationTimeoutInSeconds",
                type: {
                    name: "Number",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
            customCallingContext: {
                serializedName: "customCallingContext",
                type: {
                    name: "Composite",
                    className: "CustomCallingContextInternal",
                },
            },
        },
    },
};
const AddParticipantResponse = {
    type: {
        name: "Composite",
        className: "AddParticipantResponse",
        modelProperties: {
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CallParticipantInternal",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            invitationId: {
                serializedName: "invitationId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RemoveParticipantRequest = {
    type: {
        name: "Composite",
        className: "RemoveParticipantRequest",
        modelProperties: {
            participantToRemove: {
                serializedName: "participantToRemove",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RemoveParticipantResponse = {
    type: {
        name: "Composite",
        className: "RemoveParticipantResponse",
        modelProperties: {
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MuteParticipantsRequest = {
    type: {
        name: "Composite",
        className: "MuteParticipantsRequest",
        modelProperties: {
            targetParticipants: {
                serializedName: "targetParticipants",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationIdentifierModel",
                        },
                    },
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MuteParticipantsResult = {
    type: {
        name: "Composite",
        className: "MuteParticipantsResult",
        modelProperties: {
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CancelAddParticipantRequest = {
    type: {
        name: "Composite",
        className: "CancelAddParticipantRequest",
        modelProperties: {
            invitationId: {
                serializedName: "invitationId",
                required: true,
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            operationCallbackUri: {
                serializedName: "operationCallbackUri",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CancelAddParticipantResponse = {
    type: {
        name: "Composite",
        className: "CancelAddParticipantResponse",
        modelProperties: {
            invitationId: {
                serializedName: "invitationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StartCallRecordingRequest = {
    type: {
        name: "Composite",
        className: "StartCallRecordingRequest",
        modelProperties: {
            callLocator: {
                serializedName: "callLocator",
                type: {
                    name: "Composite",
                    className: "CallLocator",
                },
            },
            recordingStateCallbackUri: {
                serializedName: "recordingStateCallbackUri",
                type: {
                    name: "String",
                },
            },
            recordingContentType: {
                serializedName: "recordingContentType",
                type: {
                    name: "String",
                },
            },
            recordingChannelType: {
                serializedName: "recordingChannelType",
                type: {
                    name: "String",
                },
            },
            recordingFormatType: {
                serializedName: "recordingFormatType",
                type: {
                    name: "String",
                },
            },
            audioChannelParticipantOrdering: {
                serializedName: "audioChannelParticipantOrdering",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunicationIdentifierModel",
                        },
                    },
                },
            },
            channelAffinity: {
                serializedName: "channelAffinity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChannelAffinity",
                        },
                    },
                },
            },
            pauseOnStart: {
                serializedName: "pauseOnStart",
                type: {
                    name: "Boolean",
                },
            },
            recordingStorage: {
                serializedName: "externalStorage",
                type: {
                    name: "Composite",
                    className: "RecordingStorage",
                },
            },
        },
    },
};
const CallLocator = {
    type: {
        name: "Composite",
        className: "CallLocator",
        modelProperties: {
            groupCallId: {
                serializedName: "groupCallId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            kind: {
                serializedName: "kind",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ChannelAffinity = {
    type: {
        name: "Composite",
        className: "ChannelAffinity",
        modelProperties: {
            channel: {
                constraints: {
                    InclusiveMaximum: 4,
                    InclusiveMinimum: 0,
                },
                serializedName: "channel",
                type: {
                    name: "Number",
                },
            },
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const RecordingStorage = {
    type: {
        name: "Composite",
        className: "RecordingStorage",
        modelProperties: {
            recordingStorageKind: {
                serializedName: "recordingStorageKind",
                required: true,
                type: {
                    name: "String",
                },
            },
            recordingDestinationContainerUrl: {
                serializedName: "recordingDestinationContainerUrl",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RecordingStateResponse = {
    type: {
        name: "Composite",
        className: "RecordingStateResponse",
        modelProperties: {
            recordingId: {
                serializedName: "recordingId",
                type: {
                    name: "String",
                },
            },
            recordingState: {
                serializedName: "recordingState",
                type: {
                    name: "String",
                },
            },
            recordingKind: {
                serializedName: "recordingKind",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AddParticipantFailed = {
    type: {
        name: "Composite",
        className: "AddParticipantFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const ResultInformation = {
    type: {
        name: "Composite",
        className: "ResultInformation",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "Number",
                },
            },
            subCode: {
                serializedName: "subCode",
                type: {
                    name: "Number",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AddParticipantSucceeded = {
    type: {
        name: "Composite",
        className: "AddParticipantSucceeded",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const CallConnected = {
    type: {
        name: "Composite",
        className: "CallConnected",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CallDisconnected = {
    type: {
        name: "Composite",
        className: "CallDisconnected",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CallTransferAccepted = {
    type: {
        name: "Composite",
        className: "CallTransferAccepted",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            transferTarget: {
                serializedName: "transferTarget",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
            transferee: {
                serializedName: "transferee",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const CallTransferFailed = {
    type: {
        name: "Composite",
        className: "CallTransferFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const ParticipantsUpdated = {
    type: {
        name: "Composite",
        className: "ParticipantsUpdated",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            sequenceNumber: {
                serializedName: "sequenceNumber",
                type: {
                    name: "Number",
                },
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CallParticipantInternal",
                        },
                    },
                },
            },
        },
    },
};
const RemoveParticipantSucceeded = {
    type: {
        name: "Composite",
        className: "RemoveParticipantSucceeded",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const RemoveParticipantFailed = {
    type: {
        name: "Composite",
        className: "RemoveParticipantFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            participant: {
                serializedName: "participant",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel",
                },
            },
        },
    },
};
const CancelAddParticipantSucceeded = {
    type: {
        name: "Composite",
        className: "CancelAddParticipantSucceeded",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            invitationId: {
                serializedName: "invitationId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CancelAddParticipantFailed = {
    type: {
        name: "Composite",
        className: "CancelAddParticipantFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            invitationId: {
                serializedName: "invitationId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RecordingStateChanged = {
    type: {
        name: "Composite",
        className: "RecordingStateChanged",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            recordingId: {
                serializedName: "recordingId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String",
                },
            },
            startDateTime: {
                serializedName: "startDateTime",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            },
            recordingKind: {
                serializedName: "recordingKind",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PlayCompleted = {
    type: {
        name: "Composite",
        className: "PlayCompleted",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const PlayFailed = {
    type: {
        name: "Composite",
        className: "PlayFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const PlayCanceled = {
    type: {
        name: "Composite",
        className: "PlayCanceled",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RecognizeCompleted = {
    type: {
        name: "Composite",
        className: "RecognizeCompleted",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            recognitionType: {
                serializedName: "recognitionType",
                type: {
                    name: "String",
                },
            },
            dtmfResult: {
                serializedName: "dtmfResult",
                type: {
                    name: "Composite",
                    className: "DtmfResult",
                },
            },
            choiceResult: {
                serializedName: "choiceResult",
                type: {
                    name: "Composite",
                    className: "ChoiceResult",
                },
            },
            speechResult: {
                serializedName: "speechResult",
                type: {
                    name: "Composite",
                    className: "SpeechResult",
                },
            },
        },
    },
};
const DtmfResult = {
    type: {
        name: "Composite",
        className: "DtmfResult",
        modelProperties: {
            tones: {
                serializedName: "tones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ChoiceResult = {
    type: {
        name: "Composite",
        className: "ChoiceResult",
        modelProperties: {
            label: {
                serializedName: "label",
                type: {
                    name: "String",
                },
            },
            recognizedPhrase: {
                serializedName: "recognizedPhrase",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SpeechResult = {
    type: {
        name: "Composite",
        className: "SpeechResult",
        modelProperties: {
            speech: {
                serializedName: "speech",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RecognizeFailed = {
    type: {
        name: "Composite",
        className: "RecognizeFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const RecognizeCanceled = {
    type: {
        name: "Composite",
        className: "RecognizeCanceled",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContinuousDtmfRecognitionToneFailed = {
    type: {
        name: "Composite",
        className: "ContinuousDtmfRecognitionToneFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContinuousDtmfRecognitionToneReceived = {
    type: {
        name: "Composite",
        className: "ContinuousDtmfRecognitionToneReceived",
        modelProperties: {
            sequenceId: {
                serializedName: "sequenceId",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            tone: {
                serializedName: "tone",
                type: {
                    name: "String",
                },
            },
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContinuousDtmfRecognitionStopped = {
    type: {
        name: "Composite",
        className: "ContinuousDtmfRecognitionStopped",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const SendDtmfTonesCompleted = {
    type: {
        name: "Composite",
        className: "SendDtmfTonesCompleted",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};
const SendDtmfTonesFailed = {
    type: {
        name: "Composite",
        className: "SendDtmfTonesFailed",
        modelProperties: {
            callConnectionId: {
                serializedName: "callConnectionId",
                type: {
                    name: "String",
                },
            },
            serverCallId: {
                serializedName: "serverCallId",
                type: {
                    name: "String",
                },
            },
            correlationId: {
                serializedName: "correlationId",
                type: {
                    name: "String",
                },
            },
            operationContext: {
                serializedName: "operationContext",
                type: {
                    name: "String",
                },
            },
            resultInformation: {
                serializedName: "resultInformation",
                type: {
                    name: "Composite",
                    className: "ResultInformation",
                },
            },
        },
    },
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddParticipantFailed: AddParticipantFailed,
    AddParticipantRequest: AddParticipantRequest,
    AddParticipantResponse: AddParticipantResponse,
    AddParticipantSucceeded: AddParticipantSucceeded,
    AnswerCallRequest: AnswerCallRequest,
    CallConnected: CallConnected,
    CallConnectionPropertiesInternal: CallConnectionPropertiesInternal,
    CallDisconnected: CallDisconnected,
    CallIntelligenceOptionsInternal: CallIntelligenceOptionsInternal,
    CallLocator: CallLocator,
    CallParticipantInternal: CallParticipantInternal,
    CallTransferAccepted: CallTransferAccepted,
    CallTransferFailed: CallTransferFailed,
    CancelAddParticipantFailed: CancelAddParticipantFailed,
    CancelAddParticipantRequest: CancelAddParticipantRequest,
    CancelAddParticipantResponse: CancelAddParticipantResponse,
    CancelAddParticipantSucceeded: CancelAddParticipantSucceeded,
    ChannelAffinity: ChannelAffinity,
    Choice: Choice,
    ChoiceResult: ChoiceResult,
    CommunicationError: CommunicationError,
    CommunicationErrorResponse: CommunicationErrorResponse,
    CommunicationIdentifierModel: CommunicationIdentifierModel,
    CommunicationUserIdentifierModel: CommunicationUserIdentifierModel,
    ContinuousDtmfRecognitionRequest: ContinuousDtmfRecognitionRequest,
    ContinuousDtmfRecognitionStopped: ContinuousDtmfRecognitionStopped,
    ContinuousDtmfRecognitionToneFailed: ContinuousDtmfRecognitionToneFailed,
    ContinuousDtmfRecognitionToneReceived: ContinuousDtmfRecognitionToneReceived,
    CreateCallRequest: CreateCallRequest,
    CustomCallingContextInternal: CustomCallingContextInternal,
    DtmfOptions: DtmfOptions,
    DtmfResult: DtmfResult,
    FileSourceInternal: FileSourceInternal,
    GetParticipantsResponse: GetParticipantsResponse,
    MicrosoftTeamsAppIdentifierModel: MicrosoftTeamsAppIdentifierModel,
    MicrosoftTeamsUserIdentifierModel: MicrosoftTeamsUserIdentifierModel,
    MuteParticipantsRequest: MuteParticipantsRequest,
    MuteParticipantsResult: MuteParticipantsResult,
    ParticipantsUpdated: ParticipantsUpdated,
    PhoneNumberIdentifierModel: PhoneNumberIdentifierModel,
    PlayCanceled: PlayCanceled,
    PlayCompleted: PlayCompleted,
    PlayFailed: PlayFailed,
    PlayOptionsInternal: PlayOptionsInternal,
    PlayRequest: PlayRequest,
    PlaySourceInternal: PlaySourceInternal,
    RecognizeCanceled: RecognizeCanceled,
    RecognizeCompleted: RecognizeCompleted,
    RecognizeFailed: RecognizeFailed,
    RecognizeOptions: RecognizeOptions,
    RecognizeRequest: RecognizeRequest,
    RecordingStateChanged: RecordingStateChanged,
    RecordingStateResponse: RecordingStateResponse,
    RecordingStorage: RecordingStorage,
    RedirectCallRequest: RedirectCallRequest,
    RejectCallRequest: RejectCallRequest,
    RemoveParticipantFailed: RemoveParticipantFailed,
    RemoveParticipantRequest: RemoveParticipantRequest,
    RemoveParticipantResponse: RemoveParticipantResponse,
    RemoveParticipantSucceeded: RemoveParticipantSucceeded,
    ResultInformation: ResultInformation,
    SendDtmfTonesCompleted: SendDtmfTonesCompleted,
    SendDtmfTonesFailed: SendDtmfTonesFailed,
    SendDtmfTonesRequest: SendDtmfTonesRequest,
    SendDtmfTonesResult: SendDtmfTonesResult,
    SpeechOptions: SpeechOptions,
    SpeechResult: SpeechResult,
    SsmlSourceInternal: SsmlSourceInternal,
    StartCallRecordingRequest: StartCallRecordingRequest,
    TextSourceInternal: TextSourceInternal,
    TransferCallResponse: TransferCallResponse,
    TransferToParticipantRequest: TransferToParticipantRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const createCallRequest = {
    parameterPath: "createCallRequest",
    mapper: CreateCallRequest,
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2024-04-15",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const repeatabilityRequestID = {
    parameterPath: ["options", "repeatabilityRequestID"],
    mapper: {
        serializedName: "Repeatability-Request-ID",
        type: {
            name: "Uuid",
        },
    },
};
const repeatabilityFirstSent = {
    parameterPath: ["options", "repeatabilityFirstSent"],
    mapper: {
        serializedName: "Repeatability-First-Sent",
        type: {
            name: "DateTimeRfc1123",
        },
    },
};
const answerCallRequest = {
    parameterPath: "answerCallRequest",
    mapper: AnswerCallRequest,
};
const redirectCallRequest = {
    parameterPath: "redirectCallRequest",
    mapper: RedirectCallRequest,
};
const rejectCallRequest = {
    parameterPath: "rejectCallRequest",
    mapper: RejectCallRequest,
};
const callConnectionId = {
    parameterPath: "callConnectionId",
    mapper: {
        serializedName: "callConnectionId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const transferToParticipantRequest = {
    parameterPath: "transferToParticipantRequest",
    mapper: TransferToParticipantRequest,
};
const addParticipantRequest = {
    parameterPath: "addParticipantRequest",
    mapper: AddParticipantRequest,
};
const removeParticipantRequest = {
    parameterPath: "removeParticipantRequest",
    mapper: RemoveParticipantRequest,
};
const muteParticipantsRequest = {
    parameterPath: "muteParticipantsRequest",
    mapper: MuteParticipantsRequest,
};
const cancelAddParticipantRequest = {
    parameterPath: "cancelAddParticipantRequest",
    mapper: CancelAddParticipantRequest,
};
const participantRawId = {
    parameterPath: "participantRawId",
    mapper: {
        serializedName: "participantRawId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const playRequest = {
    parameterPath: "playRequest",
    mapper: PlayRequest,
};
const recognizeRequest = {
    parameterPath: "recognizeRequest",
    mapper: RecognizeRequest,
};
const continuousDtmfRecognitionRequest = {
    parameterPath: "continuousDtmfRecognitionRequest",
    mapper: ContinuousDtmfRecognitionRequest,
};
const sendDtmfTonesRequest = {
    parameterPath: "sendDtmfTonesRequest",
    mapper: SendDtmfTonesRequest,
};
const startCallRecording = {
    parameterPath: "startCallRecording",
    mapper: StartCallRecordingRequest,
};
const recordingId = {
    parameterPath: "recordingId",
    mapper: {
        serializedName: "recordingId",
        required: true,
        type: {
            name: "String",
        },
    },
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CallConnection operations. */
class CallConnectionImpl {
    /**
     * Initialize a new instance of the class CallConnection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get participants from a call. Recording and transcription bots are omitted from this list.
     * @param callConnectionId The call connection Id
     * @param options The options parameters.
     */
    listParticipants(callConnectionId, options) {
        const iter = this.getParticipantsPagingAll(callConnectionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getParticipantsPagingPage(callConnectionId, options, settings);
            },
        };
    }
    getParticipantsPagingPage(callConnectionId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getParticipantsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getParticipants(callConnectionId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getParticipantsNext(callConnectionId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getParticipantsPagingAll(callConnectionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* getParticipantsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getParticipantsPagingPage(callConnectionId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the detail properties of an ongoing call.
     * @param callConnectionId The call connection id.
     * @param options The options parameters.
     */
    getCall(callConnectionId, options) {
        return this.client.sendOperationRequest({ callConnectionId, options }, getCallOperationSpec);
    }
    /**
     * Hang up call automation service from the call. This will make call automation service leave the
     * call, but does not terminate if there are more than 1 caller in the call.
     * @param callConnectionId The call connection id.
     * @param options The options parameters.
     */
    hangupCall(callConnectionId, options) {
        return this.client.sendOperationRequest({ callConnectionId, options }, hangupCallOperationSpec);
    }
    /**
     * Terminate a call using CallConnectionId.
     * @param callConnectionId The terminate call request.
     * @param options The options parameters.
     */
    terminateCall(callConnectionId, options) {
        return this.client.sendOperationRequest({ callConnectionId, options }, terminateCallOperationSpec);
    }
    /**
     * Transfer the call to a participant.
     * @param callConnectionId The call connection id.
     * @param transferToParticipantRequest The transfer to participant request.
     * @param options The options parameters.
     */
    transferToParticipant(callConnectionId, transferToParticipantRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, transferToParticipantRequest, options }, transferToParticipantOperationSpec);
    }
    /**
     * Get participants from a call. Recording and transcription bots are omitted from this list.
     * @param callConnectionId The call connection Id
     * @param options The options parameters.
     */
    _getParticipants(callConnectionId, options) {
        return this.client.sendOperationRequest({ callConnectionId, options }, getParticipantsOperationSpec);
    }
    /**
     * Add a participant to the call.
     * @param callConnectionId The call connection Id
     * @param addParticipantRequest The request payload for adding participant to the call.
     * @param options The options parameters.
     */
    addParticipant(callConnectionId, addParticipantRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, addParticipantRequest, options }, addParticipantOperationSpec);
    }
    /**
     * Remove a participant from the call using identifier.
     * @param callConnectionId The call connection id.
     * @param removeParticipantRequest The participant to be removed from the call.
     * @param options The options parameters.
     */
    removeParticipant(callConnectionId, removeParticipantRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, removeParticipantRequest, options }, removeParticipantOperationSpec);
    }
    /**
     * Mute participants from the call using identifier.
     * @param callConnectionId The call connection id.
     * @param muteParticipantsRequest The participants to be muted from the call.
     * @param options The options parameters.
     */
    mute(callConnectionId, muteParticipantsRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, muteParticipantsRequest, options }, muteOperationSpec);
    }
    /**
     * Cancel add participant operation.
     * @param callConnectionId The call connection Id
     * @param cancelAddParticipantRequest Cancellation request.
     * @param options The options parameters.
     */
    cancelAddParticipant(callConnectionId, cancelAddParticipantRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, cancelAddParticipantRequest, options }, cancelAddParticipantOperationSpec);
    }
    /**
     * Get participant from a call.
     * @param callConnectionId The call connection Id
     * @param participantRawId Raw id of the participant to retrieve.
     * @param options The options parameters.
     */
    getParticipant(callConnectionId, participantRawId, options) {
        return this.client.sendOperationRequest({ callConnectionId, participantRawId, options }, getParticipantOperationSpec);
    }
    /**
     * GetParticipantsNext
     * @param callConnectionId The call connection Id
     * @param nextLink The nextLink from the previous successful call to the GetParticipants method.
     * @param options The options parameters.
     */
    _getParticipantsNext(callConnectionId, nextLink, options) {
        return this.client.sendOperationRequest({ callConnectionId, nextLink, options }, getParticipantsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getCallOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CallConnectionPropertiesInternal,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [accept],
    serializer: serializer$4,
};
const hangupCallOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [accept],
    serializer: serializer$4,
};
const terminateCallOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:terminate",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    serializer: serializer$4,
};
const transferToParticipantOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:transferToParticipant",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: TransferCallResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: transferToParticipantRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$4,
};
const getParticipantsOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetParticipantsResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [accept],
    serializer: serializer$4,
};
const addParticipantOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants:add",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: AddParticipantResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: addParticipantRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$4,
};
const removeParticipantOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants:remove",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: RemoveParticipantResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: removeParticipantRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$4,
};
const muteOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants:mute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: MuteParticipantsResult,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: muteParticipantsRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$4,
};
const cancelAddParticipantOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants:cancelAddParticipant",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: CancelAddParticipantResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: cancelAddParticipantRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$4,
};
const getParticipantOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}/participants/{participantRawId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CallParticipantInternal,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        callConnectionId,
        participantRawId,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const getParticipantsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetParticipantsResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    urlParameters: [
        endpoint,
        callConnectionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing CallMedia operations. */
class CallMediaImpl {
    /**
     * Initialize a new instance of the class CallMedia class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Plays audio to participants in the call.
     * @param callConnectionId The call connection id.
     * @param playRequest play request payload.
     * @param options The options parameters.
     */
    play(callConnectionId, playRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, playRequest, options }, playOperationSpec);
    }
    /**
     * Cancel all media operations in a call.
     * @param callConnectionId The call connection id
     * @param options The options parameters.
     */
    cancelAllMediaOperations(callConnectionId, options) {
        return this.client.sendOperationRequest({ callConnectionId, options }, cancelAllMediaOperationsOperationSpec);
    }
    /**
     * Recognize media from call.
     * @param callConnectionId The call connection id
     * @param recognizeRequest The media recognize request
     * @param options The options parameters.
     */
    recognize(callConnectionId, recognizeRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, recognizeRequest, options }, recognizeOperationSpec);
    }
    /**
     * Start continuous Dtmf recognition by subscribing to tones.
     * @param callConnectionId The call connection id
     * @param continuousDtmfRecognitionRequest The continuous recognize request
     * @param options The options parameters.
     */
    startContinuousDtmfRecognition(callConnectionId, continuousDtmfRecognitionRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, continuousDtmfRecognitionRequest, options }, startContinuousDtmfRecognitionOperationSpec);
    }
    /**
     * Stop continuous Dtmf recognition by unsubscribing to tones.
     * @param callConnectionId The call connection id
     * @param continuousDtmfRecognitionRequest The continuous recognize request
     * @param options The options parameters.
     */
    stopContinuousDtmfRecognition(callConnectionId, continuousDtmfRecognitionRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, continuousDtmfRecognitionRequest, options }, stopContinuousDtmfRecognitionOperationSpec);
    }
    /**
     * Send dtmf tones.
     * @param callConnectionId The call connection id
     * @param sendDtmfTonesRequest The send dtmf tones request
     * @param options The options parameters.
     */
    sendDtmfTones(callConnectionId, sendDtmfTonesRequest, options) {
        return this.client.sendOperationRequest({ callConnectionId, sendDtmfTonesRequest, options }, sendDtmfTonesOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const playOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:play",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: playRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3,
};
const cancelAllMediaOperationsOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:cancelAllMediaOperations",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [accept],
    serializer: serializer$3,
};
const recognizeOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:recognize",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: recognizeRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3,
};
const startContinuousDtmfRecognitionOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:startContinuousDtmfRecognition",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: continuousDtmfRecognitionRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3,
};
const stopContinuousDtmfRecognitionOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:stopContinuousDtmfRecognition",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: continuousDtmfRecognitionRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3,
};
const sendDtmfTonesOperationSpec = {
    path: "/calling/callConnections/{callConnectionId}:sendDtmfTones",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: SendDtmfTonesResult,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: sendDtmfTonesRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, callConnectionId],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$3,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing CallRecording operations. */
class CallRecordingImpl {
    /**
     * Initialize a new instance of the class CallRecording class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Start recording the call.
     * @param startCallRecording The request body of start call recording request.
     * @param options The options parameters.
     */
    startRecording(startCallRecording, options) {
        return this.client.sendOperationRequest({ startCallRecording, options }, startRecordingOperationSpec);
    }
    /**
     * Get call recording properties.
     * @param recordingId The recording id.
     * @param options The options parameters.
     */
    getRecordingProperties(recordingId, options) {
        return this.client.sendOperationRequest({ recordingId, options }, getRecordingPropertiesOperationSpec);
    }
    /**
     * Stop recording the call.
     * @param recordingId The recording id.
     * @param options The options parameters.
     */
    stopRecording(recordingId, options) {
        return this.client.sendOperationRequest({ recordingId, options }, stopRecordingOperationSpec);
    }
    /**
     * Pause recording the call.
     * @param recordingId The recording id.
     * @param options The options parameters.
     */
    pauseRecording(recordingId, options) {
        return this.client.sendOperationRequest({ recordingId, options }, pauseRecordingOperationSpec);
    }
    /**
     * Resume recording the call.
     * @param recordingId The recording id.
     * @param options The options parameters.
     */
    resumeRecording(recordingId, options) {
        return this.client.sendOperationRequest({ recordingId, options }, resumeRecordingOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const startRecordingOperationSpec = {
    path: "/calling/recordings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RecordingStateResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: startCallRecording,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$2,
};
const getRecordingPropertiesOperationSpec = {
    path: "/calling/recordings/{recordingId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecordingStateResponse,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, recordingId],
    headerParameters: [accept],
    serializer: serializer$2,
};
const stopRecordingOperationSpec = {
    path: "/calling/recordings/{recordingId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, recordingId],
    headerParameters: [accept],
    serializer: serializer$2,
};
const pauseRecordingOperationSpec = {
    path: "/calling/recordings/{recordingId}:pause",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, recordingId],
    headerParameters: [accept],
    serializer: serializer$2,
};
const resumeRecordingOperationSpec = {
    path: "/calling/recordings/{recordingId}:resume",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, recordingId],
    headerParameters: [accept],
    serializer: serializer$2,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class CallAutomationApiClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the CallAutomationApiClient class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
        };
        const packageDetails = `azsdk-js-communication-call-automation/1.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2024-04-15";
        this.callConnection = new CallConnectionImpl(this);
        this.callMedia = new CallMediaImpl(this);
        this.callRecording = new CallRecordingImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Create an outbound call.
     * @param createCallRequest The create call request.
     * @param options The options parameters.
     */
    createCall(createCallRequest, options) {
        return this.sendOperationRequest({ createCallRequest, options }, createCallOperationSpec);
    }
    /**
     * Answer a call using the IncomingCallContext from Event Grid.
     * @param answerCallRequest The answer call request.
     * @param options The options parameters.
     */
    answerCall(answerCallRequest, options) {
        return this.sendOperationRequest({ answerCallRequest, options }, answerCallOperationSpec);
    }
    /**
     * Redirect a call.
     * @param redirectCallRequest The redirect call request.
     * @param options The options parameters.
     */
    redirectCall(redirectCallRequest, options) {
        return this.sendOperationRequest({ redirectCallRequest, options }, redirectCallOperationSpec);
    }
    /**
     * Reject the call.
     * @param rejectCallRequest The reject call request.
     * @param options The options parameters.
     */
    rejectCall(rejectCallRequest, options) {
        return this.sendOperationRequest({ rejectCallRequest, options }, rejectCallOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createCallOperationSpec = {
    path: "/calling/callConnections",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CallConnectionPropertiesInternal,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: createCallRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$1,
};
const answerCallOperationSpec = {
    path: "/calling/callConnections:answer",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CallConnectionPropertiesInternal,
        },
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: answerCallRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$1,
};
const redirectCallOperationSpec = {
    path: "/calling/callConnections:redirect",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: redirectCallRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$1,
};
const rejectCallOperationSpec = {
    path: "/calling/callConnections:reject",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse,
        },
    },
    requestBody: rejectCallRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        repeatabilityRequestID,
        repeatabilityFirstSent,
    ],
    mediaType: "json",
    serializer: serializer$1,
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * CallMedia class represents call media related APIs.
 */
class CallMedia {
    constructor(callConnectionId, endpoint, credential, options) {
        this.callAutomationApiClient = new CallAutomationApiClient(endpoint, options);
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.callConnectionId = callConnectionId;
        this.callMedia = new CallMediaImpl(this.callAutomationApiClient);
    }
    createPlaySourceInternal(playSource) {
        if (playSource.kind === "fileSource") {
            const fileSource = {
                uri: playSource.url,
            };
            return {
                kind: KnownPlaySourceType.File,
                file: fileSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        else if (playSource.kind === "textSource") {
            const textSource = {
                text: playSource.text,
                sourceLocale: playSource.sourceLocale,
                voiceKind: playSource.voiceKind,
                voiceName: playSource.voiceName,
                customVoiceEndpointId: playSource.customVoiceEndpointId,
            };
            return {
                kind: KnownPlaySourceType.Text,
                text: textSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        else if (playSource.kind === "ssmlSource") {
            const ssmlSource = {
                ssmlText: playSource.ssmlText,
                customVoiceEndpointId: playSource.customVoiceEndpointId,
            };
            return {
                kind: KnownPlaySourceType.Ssml,
                ssml: ssmlSource,
                playSourceCacheId: playSource.playsourcacheid,
            };
        }
        throw new Error("Invalid play source");
    }
    /**
     * Play audio to a specific participant.
     *
     * @param playSources - A PlaySource representing the sources to play. Currently only single play source per request is supported.
     * @param playTo - The targets to play to.
     * @param options - Additional attributes for play.
     */
    async play(playSources, playTo, options = { loop: false }) {
        const playRequest = {
            playSources: playSources.map((source) => this.createPlaySourceInternal(source)),
            playTo: playTo.map((identifier) => communicationCommon.serializeCommunicationIdentifier(identifier)),
            playOptions: {
                loop: false,
            },
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        if (options.loop !== undefined) {
            playRequest.playOptions = playRequest.playOptions || { loop: false }; // Ensure playOptions is defined
            playRequest.playOptions.loop = options.loop;
        }
        return this.callMedia.play(this.callConnectionId, playRequest, options);
    }
    /**
     * Play to all participants.
     *
     * @param playSources - A PlaySource representing the sources to play. Currently only single play source per request is supported.
     * @param options - Additional attributes for play.
     */
    async playToAll(playSources, options = { loop: false }) {
        const playRequest = {
            playSources: playSources.map((source) => this.createPlaySourceInternal(source)),
            playTo: [],
            playOptions: {
                loop: false,
            },
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        if (options.loop !== undefined) {
            playRequest.playOptions = playRequest.playOptions || { loop: false }; // Ensure playOptions is defined
            playRequest.playOptions.loop = options.loop;
        }
        return this.callMedia.play(this.callConnectionId, playRequest, options);
    }
    createRecognizeRequest(targetParticipant, recognizeOptions) {
        if (recognizeOptions.kind === "callMediaRecognizeDtmfOptions") {
            const dtmfOptionsInternal = {
                interToneTimeoutInSeconds: recognizeOptions.interToneTimeoutInSeconds
                    ? recognizeOptions.interToneTimeoutInSeconds
                    : 2,
                maxTonesToCollect: recognizeOptions.maxTonesToCollect,
                stopTones: recognizeOptions.stopDtmfTones,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
                dtmfOptions: dtmfOptionsInternal,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Dtmf,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeChoiceOptions") {
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
                speechLanguage: recognizeOptions.speechLanguage,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
                choices: recognizeOptions.choices,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Choices,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeSpeechOptions") {
            const speechOptions = {
                endSilenceTimeoutInMs: recognizeOptions.endSilenceTimeoutInSeconds
                    ? recognizeOptions.endSilenceTimeoutInSeconds * 1000
                    : 2000,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
                speechOptions: speechOptions,
                speechLanguage: recognizeOptions.speechLanguage,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.Speech,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        else if (recognizeOptions.kind === "callMediaRecognizeSpeechOrDtmfOptions") {
            const dtmfOptionsInternal = {
                interToneTimeoutInSeconds: recognizeOptions.interToneTimeoutInSeconds
                    ? recognizeOptions.interToneTimeoutInSeconds
                    : 2,
                maxTonesToCollect: recognizeOptions.maxTonesToCollect,
                stopTones: recognizeOptions.stopDtmfTones,
            };
            const speechOptions = {
                endSilenceTimeoutInMs: recognizeOptions.endSilenceTimeoutInSeconds
                    ? recognizeOptions.endSilenceTimeoutInSeconds * 1000
                    : 2000,
            };
            const recognizeOptionsInternal = {
                interruptPrompt: recognizeOptions.interruptPrompt,
                initialSilenceTimeoutInSeconds: recognizeOptions.initialSilenceTimeoutInSeconds
                    ? recognizeOptions.initialSilenceTimeoutInSeconds
                    : 5,
                targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
                speechOptions: speechOptions,
                dtmfOptions: dtmfOptionsInternal,
                speechLanguage: recognizeOptions.speechLanguage,
                speechRecognitionModelEndpointId: recognizeOptions.speechRecognitionModelEndpointId,
            };
            return {
                recognizeInputType: KnownRecognizeInputType.SpeechOrDtmf,
                playPrompt: recognizeOptions.playPrompt
                    ? this.createPlaySourceInternal(recognizeOptions.playPrompt)
                    : undefined,
                interruptCallMediaOperation: recognizeOptions.interruptCallMediaOperation,
                recognizeOptions: recognizeOptionsInternal,
                operationContext: recognizeOptions.operationContext,
                operationCallbackUri: recognizeOptions.operationCallbackUrl,
            };
        }
        throw new Error("Invalid recognizeOptions");
    }
    async startRecognizing(targetParticipant, maxTonesOrOptions, options) {
        if (typeof maxTonesOrOptions === "number" && options) {
            // Old function signature logic
            console.warn("Deprecated function signature used. Please use the new signature with targetParticipant and options params instead, and set maxTonesToCollect in options.");
            options.maxTonesToCollect = maxTonesOrOptions;
            return this.callMedia.recognize(this.callConnectionId, this.createRecognizeRequest(targetParticipant, options), {});
        }
        else if (typeof maxTonesOrOptions !== "number" && !options) {
            // New function signature logic
            return this.callMedia.recognize(this.callConnectionId, this.createRecognizeRequest(targetParticipant, maxTonesOrOptions), {});
        }
        throw new Error("Invalid params");
    }
    /**
     * Cancels all the queued media operations.
     */
    async cancelAllOperations() {
        return this.callMedia.cancelAllMediaOperations(this.callConnectionId, {});
    }
    /**
     * Start continuous Dtmf recognition by subscribing to tones.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for continuous Dtmf recognition.
     * */
    async startContinuousDtmfRecognition(targetParticipant, options = {}) {
        const continuousDtmfRecognitionRequest = {
            targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
        };
        return this.callMedia.startContinuousDtmfRecognition(this.callConnectionId, continuousDtmfRecognitionRequest, {});
    }
    /**
     * Stop continuous Dtmf recognition by unsubscribing to tones.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for continuous Dtmf recognition.
     * */
    async stopContinuousDtmfRecognition(targetParticipant, options = {}) {
        const continuousDtmfRecognitionRequest = {
            targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        return this.callMedia.stopContinuousDtmfRecognition(this.callConnectionId, continuousDtmfRecognitionRequest, {});
    }
    /**
     * Send Dtmf tones.
     * @param tones - List of tones to be sent to target participant.
     * @param targetParticipant - Target participant.
     * @param options - Additional attributes for send Dtmf tones.
     * */
    async sendDtmfTones(tones, targetParticipant, options = {}) {
        const sendDtmfTonesRequest = {
            tones: tones,
            targetParticipant: communicationCommon.serializeCommunicationIdentifier(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const result = await this.callMedia.sendDtmfTones(this.callConnectionId, sendDtmfTonesRequest, optionsInternal);
        const sendDtmfTonesResult = Object.assign({}, result);
        return sendDtmfTonesResult;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function extractKind(identifierModel) {
    if (identifierModel.communicationUser !== undefined) {
        return KnownCommunicationIdentifierModelKind.CommunicationUser;
    }
    if (identifierModel.phoneNumber !== undefined) {
        return KnownCommunicationIdentifierModelKind.PhoneNumber;
    }
    if (identifierModel.microsoftTeamsUser !== undefined) {
        return KnownCommunicationIdentifierModelKind.MicrosoftTeamsUser;
    }
    if (identifierModel.microsoftTeamsApp !== undefined) {
        return KnownCommunicationIdentifierModelKind.MicrosoftTeamsApp;
    }
    return KnownCommunicationIdentifierModelKind.Unknown;
}
/** Convert PhoneNumberIdentifier to PhoneNumberIdentifierModel(Internal usage class) */
function PhoneNumberIdentifierModelConverter(phoneNumberIdentifier) {
    if (phoneNumberIdentifier === undefined || phoneNumberIdentifier.phoneNumber === undefined) {
        return undefined;
    }
    const phoneNumberIdentifierModel = communicationCommon.serializeCommunicationIdentifier(phoneNumberIdentifier).phoneNumber;
    return phoneNumberIdentifierModel;
}
/** Convert SerializedPhoneNumberIdentifier to PhoneNumberIdentifier(Public usage class) */
function phoneNumberIdentifierConverter(serializedPhoneNumberIdentifier) {
    if (serializedPhoneNumberIdentifier === undefined ||
        (serializedPhoneNumberIdentifier === null || serializedPhoneNumberIdentifier === void 0 ? void 0 : serializedPhoneNumberIdentifier.value) === null) {
        return undefined;
    }
    const phoneNumberIdentifier = {
        phoneNumber: serializedPhoneNumberIdentifier.value,
    };
    return phoneNumberIdentifier;
}
/** Convert CommunicationIdentifierModel to CommunicationIdentifier(Public usage class) */
function communicationIdentifierConverter(identifierModel) {
    const rawId = identifierModel.rawId;
    const kind = identifierModel.kind !== undefined ? identifierModel.kind : extractKind(identifierModel);
    if (kind === KnownCommunicationIdentifierModelKind.CommunicationUser &&
        identifierModel.communicationUser !== undefined) {
        const communicationUserIdentifier = {
            communicationUserId: identifierModel.communicationUser.id,
        };
        return communicationUserIdentifier;
    }
    if (kind === KnownCommunicationIdentifierModelKind.PhoneNumber &&
        identifierModel.phoneNumber !== undefined) {
        const phoneNumberIdentifier = {
            phoneNumber: identifierModel.phoneNumber.value,
            rawId: rawId,
        };
        return phoneNumberIdentifier;
    }
    if (kind === KnownCommunicationIdentifierModelKind.MicrosoftTeamsUser &&
        identifierModel.microsoftTeamsUser !== undefined) {
        const microsoftTeamsUserIdentifier = {
            rawId: rawId,
            microsoftTeamsUserId: identifierModel.microsoftTeamsUser.userId,
            isAnonymous: identifierModel.microsoftTeamsUser.isAnonymous,
            cloud: identifierModel.microsoftTeamsUser.cloud,
        };
        return microsoftTeamsUserIdentifier;
    }
    if (kind === KnownCommunicationIdentifierModelKind.MicrosoftTeamsApp &&
        identifierModel.microsoftTeamsApp !== undefined) {
        const microsoftTeamsAppIdentifier = {
            teamsAppId: identifierModel.microsoftTeamsApp.appId,
            cloud: identifierModel.microsoftTeamsApp.cloud,
            rawId: rawId,
        };
        return microsoftTeamsAppIdentifier;
    }
    const unknownIdentifier = {
        id: rawId ? rawId : "",
    };
    return unknownIdentifier;
}
/** Convert CommunicationIdentifier to CommunicationIdentifierModel(Internal usage class) */
function communicationIdentifierModelConverter(identifier) {
    const serializedIdentifier = communicationCommon.serializeCommunicationIdentifier(identifier);
    if (communicationCommon.isCommunicationUserIdentifier(identifier)) {
        const communicationUserIdentifierModel = Object.assign({ kind: KnownCommunicationIdentifierModelKind.CommunicationUser }, serializedIdentifier);
        return communicationUserIdentifierModel;
    }
    if (communicationCommon.isPhoneNumberIdentifier(identifier)) {
        const phoneNumberIdentifierModel = Object.assign({ kind: KnownCommunicationIdentifierModelKind.PhoneNumber }, serializedIdentifier);
        return phoneNumberIdentifierModel;
    }
    if (communicationCommon.isMicrosoftTeamsUserIdentifier(identifier)) {
        const microsoftTeamsUserIdentifierModel = Object.assign({ kind: KnownCommunicationIdentifierModelKind.MicrosoftTeamsUser }, serializedIdentifier);
        return microsoftTeamsUserIdentifierModel;
    }
    if (communicationCommon.isMicrosoftTeamsAppIdentifier(identifier)) {
        const microsoftTeamsAppIdentifier = Object.assign({ kind: KnownCommunicationIdentifierModelKind.MicrosoftTeamsApp }, serializedIdentifier);
        return microsoftTeamsAppIdentifier;
    }
    if (communicationCommon.isUnknownIdentifier(identifier)) {
        const unknownIdentifierModel = Object.assign({ kind: KnownCommunicationIdentifierModelKind.Unknown }, serializedIdentifier);
        return unknownIdentifierModel;
    }
    throw new Error();
}
/** Convert CallParticipantInternal to CallParticipant */
function callParticipantConverter(acsCallParticipant) {
    const callParticipant = Object.assign(Object.assign({}, acsCallParticipant), { identifier: acsCallParticipant.identifier
            ? communicationIdentifierConverter(acsCallParticipant.identifier)
            : undefined });
    return callParticipant;
}
/** Convert CommunicationUserIdentifier to CommunicationUserIdentifierModel (Internal usage class) */
function communicationUserIdentifierModelConverter(identifier) {
    if (!identifier || !identifier.communicationUserId) {
        return undefined;
    }
    return { id: identifier.communicationUserId };
}
/** Convert CommunicationUserIdentifierModel to CommunicationUserIdentifier (Public usage class) */
function communicationUserIdentifierConverter(identifier) {
    if (!identifier || !identifier.id) {
        return undefined;
    }
    return { communicationUserId: identifier.id };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * CallConnection class represents call connection based APIs.
 */
class CallConnection {
    constructor(callConnectionId, endpoint, credential, options) {
        this.callAutomationApiClient = new CallAutomationApiClient(endpoint, options);
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.callConnectionId = callConnectionId;
        this.callConnection = new CallConnectionImpl(this.callAutomationApiClient);
        this.endpoint = endpoint;
        this.credential = credential;
        this.callAutomationApiClientOptions = options;
    }
    /**
     * Initializes a new instance of CallMedia.
     */
    getCallMedia() {
        return new CallMedia(this.callConnectionId, this.endpoint, this.credential, this.callAutomationApiClientOptions);
    }
    /**
     * Get call connection properties of the call
     */
    async getCallConnectionProperties(options = {}) {
        const _a = await this.callConnection.getCall(this.callConnectionId, options), { targets, sourceCallerIdNumber, answeredBy, source } = _a, result = tslib.__rest(_a, ["targets", "sourceCallerIdNumber", "answeredBy", "source"]);
        const callConnectionProperties = Object.assign(Object.assign({}, result), { source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((target) => communicationIdentifierConverter(target)), sourceCallerIdNumber: sourceCallerIdNumber
                ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                : undefined });
        return callConnectionProperties;
    }
    /**
     * Hang up the call for itself or terminate the whole call.
     *
     * @param isForEveryOne - Determine if every one in the call would be hung up or not.
     */
    async hangUp(isForEveryone, options = {}) {
        if (isForEveryone) {
            const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
            await this.callConnection.terminateCall(this.callConnectionId, optionsInternal);
        }
        else {
            await this.callConnection.hangupCall(this.callConnectionId, options);
        }
        return;
    }
    /**
     * Get a participant from the call
     *
     * @param targetParticipant - The communication identifier of requested participant.
     */
    async getParticipant(targetParticipant, options = {}) {
        let rawId = communicationIdentifierModelConverter(targetParticipant).rawId;
        rawId = rawId === undefined ? "" : rawId;
        const result = await this.callConnection.getParticipant(this.callConnectionId, rawId, options);
        const callParticipant = {
            identifier: result.identifier
                ? communicationIdentifierConverter(result.identifier)
                : undefined,
            isMuted: result.isMuted,
        };
        return callParticipant;
    }
    /**
     * Get all participants from the call
     */
    async listParticipants(options = {}) {
        var _a, e_1, _b, _c;
        const result = this.callConnection.listParticipants(this.callConnectionId, options);
        const participants = [];
        const pages = result === null || result === void 0 ? void 0 : result.byPage();
        try {
            for (var _d = true, pages_1 = tslib.__asyncValues(pages), pages_1_1; pages_1_1 = await pages_1.next(), _a = pages_1_1.done, !_a; _d = true) {
                _c = pages_1_1.value;
                _d = false;
                const page = _c;
                for (const participant of page) {
                    participants.push(callParticipantConverter(participant));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = pages_1.return)) await _b.call(pages_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const listParticipantResponse = Object.assign(Object.assign({}, result), { values: participants });
        return listParticipantResponse;
    }
    createCustomCallingContextInternal(customCallingContext) {
        const sipHeaders = {};
        const voipHeaders = {};
        if (customCallingContext) {
            for (const header of customCallingContext) {
                if (header.kind === "sipuui") {
                    sipHeaders[`User-To-User`] = header.value;
                }
                else if (header.kind === "sipx") {
                    sipHeaders[`X-MS-Custom-${header.key}`] = header.value;
                }
                else if (header.kind === "voip") {
                    voipHeaders[`${header.key}`] = header.value;
                }
            }
        }
        return { sipHeaders: sipHeaders, voipHeaders: voipHeaders };
    }
    /**
     * Add a participant to the call
     *
     * @param participant - The participant is going to be added.
     */
    async addParticipant(targetParticipant, options = {}) {
        var _a, _b;
        const addParticipantRequest = {
            participantToAdd: communicationIdentifierModelConverter(targetParticipant.targetParticipant),
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(targetParticipant.sourceCallIdNumber),
            sourceDisplayName: targetParticipant.sourceDisplayName,
            invitationTimeoutInSeconds: options.invitationTimeoutInSeconds,
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
            customCallingContext: this.createCustomCallingContextInternal(targetParticipant.customCallingContext),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const result = await this.callConnection.addParticipant(this.callConnectionId, addParticipantRequest, optionsInternal);
        const addParticipantsResult = Object.assign(Object.assign({}, result), { participant: Object.assign(Object.assign({}, result.participant), { identifier: ((_a = result.participant) === null || _a === void 0 ? void 0 : _a.identifier)
                    ? communicationIdentifierConverter((_b = result.participant) === null || _b === void 0 ? void 0 : _b.identifier)
                    : undefined }) });
        return addParticipantsResult;
    }
    /**
     * Transfer the call to a target participant
     *
     * @param targetParticipant - The target to be transferred to.
     */
    async transferCallToParticipant(targetParticipant, options = {}) {
        const transferToParticipantRequest = {
            targetParticipant: communicationIdentifierModelConverter(targetParticipant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
            transferee: options.transferee && communicationIdentifierModelConverter(options.transferee),
            customCallingContext: this.createCustomCallingContextInternal(options.customCallingContext),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const result = await this.callConnection.transferToParticipant(this.callConnectionId, transferToParticipantRequest, optionsInternal);
        const transferCallResult = Object.assign({}, result);
        return transferCallResult;
    }
    /**
     * Remove a participant from the call
     *
     * @param participant - The participant is going to be removed from the call.
     */
    async removeParticipant(participant, options = {}) {
        const removeParticipantRequest = {
            participantToRemove: communicationIdentifierModelConverter(participant),
            operationContext: options.operationContext,
            operationCallbackUri: options.operationCallbackUrl,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const result = await this.callConnection.removeParticipant(this.callConnectionId, removeParticipantRequest, optionsInternal);
        const removeParticipantsResult = Object.assign({}, result);
        return removeParticipantsResult;
    }
    /**
     * Mute participant from the call.
     *
     * @param participant - Participant to be muted from the call.
     * @param options - Additional attributes for mute participant.
     */
    async muteParticipant(participant, options = {}) {
        const muteParticipantsRequest = {
            targetParticipants: [communicationIdentifierModelConverter(participant)],
            operationContext: options.operationContext,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const result = await this.callConnection.mute(this.callConnectionId, muteParticipantsRequest, optionsInternal);
        const muteParticipantResult = Object.assign({}, result);
        return muteParticipantResult;
    }
    /** Cancel add participant operation.
     *
     * @param invitationId - Invitation ID used to cancel the add participant request.
     * @param options - Additional attributes for cancel add participant operation.
     */
    async cancelAddParticipantOperation(invitationId, options = {}) {
        const { operationContext, operationCallbackUrl: operationCallbackUri } = options, operationOptions = tslib.__rest(options, ["operationContext", "operationCallbackUrl"]);
        const cancelAddParticipantRequest = {
            invitationId,
            operationContext: options.operationContext,
            operationCallbackUri,
        };
        const optionsInternal = Object.assign(Object.assign({}, operationOptions), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        return this.callConnection.cancelAddParticipant(this.callConnectionId, cancelAddParticipantRequest, optionsInternal);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** Class containing ContentDownloading operations. */
class ContentDownloaderImpl {
    /**
     * Initialize a new instance of the class ContentDownloader class.
     * @param client - Reference to the service client
     */
    constructor(client) {
        this.client = client;
        this.addCustomSignUrlPolicy();
    }
    addCustomSignUrlPolicy() {
        const signUrlPolicy = {
            name: "CustomSignUrlPolicy",
            async sendRequest(request, next) {
                if (request.headers.has("OriginalUrl")) {
                    request.url = `${request.headers.get("OriginalUrl")}`;
                    const originalRequest = new URL(request.url);
                    request.headers.set("Host", originalRequest.host);
                }
                return next(request);
            },
        };
        const pipelineOptions = {};
        pipelineOptions.afterPhase = "Sign";
        this.client.pipeline.addPolicy(signUrlPolicy, pipelineOptions);
    }
    /**
     * Deletes a recording.
     * @param deleteLocationUrl - The recording location url. Required.
     */
    async deleteRecording(deleteLocationUrl, options) {
        var _a, _b, _c;
        const fileLocation = new URL(deleteLocationUrl);
        const endpoint = new URL(this.client.endpoint);
        const modifiedUrlForSigning = endpoint.origin + fileLocation.pathname;
        const opt = {
            url: modifiedUrlForSigning,
            method: "DELETE",
            headers: coreRestPipeline.createHttpHeaders(),
            body: "",
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            tracingOptions: options === null || options === void 0 ? void 0 : options.tracingOptions,
        };
        (_a = opt.headers) === null || _a === void 0 ? void 0 : _a.set("OriginalUrl", deleteLocationUrl);
        (_b = opt.headers) === null || _b === void 0 ? void 0 : _b.set("x-ms-host", endpoint.host);
        (_c = opt.headers) === null || _c === void 0 ? void 0 : _c.set("accept", "application/json");
        const req = coreRestPipeline.createPipelineRequest(opt);
        const results = await this.client.sendRequest(req);
        if (results.status !== 200) {
            if (results.bodyAsText) {
                const jsonBody = JSON.parse(results.bodyAsText);
                throw { status: jsonBody.status, message: jsonBody.message };
            }
            throw { status: results.status };
        }
    }
    /**
     * Returns a stream with a call recording.
     * @param sourceLocationUrl - The source location url. Required.
     * @param options - Additional request options contains downloadRecording options.
     */
    async download(sourceLocationUrl, options) {
        var _a, _b, _c, _d;
        const fileLocation = new URL(sourceLocationUrl);
        const endpoint = new URL(this.client.endpoint);
        const modifiedUrlForSigning = endpoint.origin + fileLocation.pathname;
        const opt = {
            url: modifiedUrlForSigning,
            method: "GET",
            headers: coreRestPipeline.createHttpHeaders(),
            body: "",
            streamResponseStatusCodes: new Set([200, 206]),
            abortSignal: options.abortSignal,
            tracingOptions: options === null || options === void 0 ? void 0 : options.tracingOptions,
        };
        if (options.length && !options.offset) {
            throw Error("Download offset value must not be empty if length is set.");
        }
        else if (options.length && options.offset) {
            options.length = options.offset + options.length - 1;
        }
        let rangeHeader = "bytes=" + options.offset;
        if (options.length)
            rangeHeader += "-" + options.length;
        (_a = opt.headers) === null || _a === void 0 ? void 0 : _a.set("OriginalUrl", sourceLocationUrl);
        (_b = opt.headers) === null || _b === void 0 ? void 0 : _b.set("x-ms-host", endpoint.host);
        (_c = opt.headers) === null || _c === void 0 ? void 0 : _c.set("accept", "application/json");
        (_d = opt.headers) === null || _d === void 0 ? void 0 : _d.set("Range", rangeHeader);
        const req = coreRestPipeline.createPipelineRequest(opt);
        const results = await this.client.sendRequest(req);
        if (results.status !== 200 && results.status !== 206) {
            if (results.bodyAsText) {
                const jsonBody = JSON.parse(results.bodyAsText);
                throw { status: jsonBody.status, message: jsonBody.message };
            }
            throw { status: results.status };
        }
        return results;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const shaHash = async (content) => crypto.createHash("sha256").update(content).digest("base64");
const shaHMAC = async (secret, content) => {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret).update(content).digest("base64");
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const callAutomationAccessKeyCredentialPolicy = "CallAutomationAccessKeyCredentialPolicy";
/**
 * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.
 * @hidden
 *
 * @param credential - The key credential.
 */
function createCallAutomationAccessKeyCredentialPolicy(credential, acsUrl) {
    return {
        name: callAutomationAccessKeyCredentialPolicy,
        async sendRequest(request, next) {
            var _a;
            const verb = request.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = await shaHash(((_a = request.body) === null || _a === void 0 ? void 0 : _a.toString()) || "");
            const dateHeader = "x-ms-date";
            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
            const acsUrlCast = new URL(acsUrl);
            request.headers.set("x-ms-host", acsUrlCast.host);
            const url = new URL(request.url);
            const query = url.searchParams.toString();
            const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${acsUrlCast.host};${contentHash}`;
            const signature = await shaHMAC(credential.key, stringToSign);
            if (coreUtil.isNode) {
                request.headers.set("Host", url.host || "");
            }
            request.headers.set(dateHeader, utcNow);
            request.headers.set("x-ms-content-sha256", contentHash);
            request.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a pipeline policy to authenticate request based
 * on the credential passed in.
 * @hidden
 *
 * @param credential - The KeyCredential or TokenCredential.
 */
function createCallAutomationAuthPolicy(credential, acsUrl) {
    if (coreAuth.isTokenCredential(credential)) {
        const policyOptions = {
            credential: credential,
            scopes: ["https://communication.azure.com//.default"],
        };
        return coreRestPipeline.bearerTokenAuthenticationPolicy(policyOptions);
    }
    else {
        return createCallAutomationAccessKeyCredentialPolicy(credential, acsUrl);
    }
}
/**
 * Creates CallAutomationApiClient for custom endpoint
 * @hidden
 *
 * @param credential - The KeyCredential or TokenCredential.
 * @param internalPipelineOptions - CallAutomationApiClientOptionalParams if provided.
 * @param url - ACS url.
 */
function createCustomCallAutomationApiClient(credential, internalPipelineOptions, url) {
    // read environment variable for callAutomation auth
    const customEnabled = process.env.COMMUNICATION_CUSTOM_ENDPOINT_ENABLED;
    const customUrl = process.env.COMMUNICATION_CUSTOM_URL;
    let callAutomationApiClient;
    if ((customEnabled === null || customEnabled === void 0 ? void 0 : customEnabled.toLowerCase()) === "true" && customUrl) {
        // add custom header for Call Automation auth when flag is true
        callAutomationApiClient = new CallAutomationApiClient(customUrl, internalPipelineOptions);
        const callAutomationAuthPolicy = createCallAutomationAuthPolicy(credential, url);
        callAutomationApiClient.pipeline.addPolicy(callAutomationAuthPolicy);
    }
    else {
        callAutomationApiClient = new CallAutomationApiClient(url, internalPipelineOptions);
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        callAutomationApiClient.pipeline.addPolicy(authPolicy);
    }
    return callAutomationApiClient;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * CallRecording class represents call recording related APIs.
 */
class CallRecording {
    constructor(endpoint, credential, options) {
        this.callAutomationApiClient = createCustomCallAutomationApiClient(credential, options, endpoint);
        this.callRecordingImpl = new CallRecordingImpl(this.callAutomationApiClient);
        this.contentDownloader = new ContentDownloaderImpl(this.callAutomationApiClient);
    }
    /**
     * Starts a call recording with the specified options.
     * @param startCallRecordingRequest - options to start the call recording
     * @param options - Operation options.
     */
    async start(options) {
        const startCallRecordingRequest = {
            callLocator: options.callLocator,
        };
        startCallRecordingRequest.recordingChannelType = options.recordingChannel;
        startCallRecordingRequest.recordingContentType = options.recordingContent;
        startCallRecordingRequest.recordingFormatType = options.recordingFormat;
        startCallRecordingRequest.recordingStateCallbackUri = options.recordingStateCallbackEndpointUrl;
        startCallRecordingRequest.pauseOnStart = options.pauseOnStart;
        startCallRecordingRequest.recordingStorage = options.recordingStorage;
        if (options.channelAffinity) {
            startCallRecordingRequest.channelAffinity = [];
            options.channelAffinity.forEach((identifier) => {
                var _a;
                (_a = startCallRecordingRequest.channelAffinity) === null || _a === void 0 ? void 0 : _a.push({
                    participant: communicationIdentifierModelConverter(identifier.targetParticipant),
                    channel: identifier.channel,
                });
            });
        }
        if (options.audioChannelParticipantOrdering) {
            startCallRecordingRequest.audioChannelParticipantOrdering = [];
            options.audioChannelParticipantOrdering.forEach((identifier) => {
                var _a;
                (_a = startCallRecordingRequest.audioChannelParticipantOrdering) === null || _a === void 0 ? void 0 : _a.push(communicationIdentifierModelConverter(identifier));
            });
        }
        if (options.callLocator.kind === "groupCallLocator") {
            startCallRecordingRequest.callLocator.kind = "groupCallLocator";
            startCallRecordingRequest.callLocator.groupCallId = options.callLocator.id;
        }
        else {
            startCallRecordingRequest.callLocator.kind = "serverCallLocator";
            startCallRecordingRequest.callLocator.serverCallId = options.callLocator.id;
        }
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: coreUtil.randomUUID() });
        const response = await this.callRecordingImpl.startRecording(startCallRecordingRequest, optionsInternal);
        const result = {
            recordingId: response.recordingId,
            recordingKind: response.recordingKind,
            recordingState: response.recordingState,
        };
        return result;
    }
    /**
     * Returns call recording properties.
     * @param recordingId - The recordingId associated with the recording.
     * @param options - Additional request options contains getRecordingProperties api options.
     */
    async getState(recordingId, options = {}) {
        const response = await this.callRecordingImpl.getRecordingProperties(recordingId, options);
        const result = {
            recordingId: response.recordingId,
            recordingKind: response.recordingKind,
            recordingState: response.recordingState,
        };
        return result;
    }
    /**
     * Stops a call recording.
     * @param recordingId - The recordingId associated with the recording.
     * @param options - Additional request options contains stopRecording api options.
     */
    async stop(recordingId, options = {}) {
        return this.callRecordingImpl.stopRecording(recordingId, options);
    }
    /**
     * Pauses a call recording.
     * @param recordingId - The recordingId associated with the recording.
     * @param options - Additional request options contains pauseRecording api options.
     */
    async pause(recordingId, options = {}) {
        return this.callRecordingImpl.pauseRecording(recordingId, options);
    }
    /**
     * Resumes a call recording.
     * @param recordingId - The recordingId associated with the recording.
     * @param options - Additional request options contains resumeRecording api options.
     */
    async resume(recordingId, options = {}) {
        return this.callRecordingImpl.resumeRecording(recordingId, options);
    }
    /**
     * Deletes a recording.
     * @param recordingLocationUrl - The recording location url. Required.
     * @param options - Additional request options contains deleteRecording api options.
     */
    async delete(recordingLocationUrl, options = {}) {
        await this.contentDownloader.deleteRecording(recordingLocationUrl, options);
    }
    /**
     * Returns a stream with a call recording.
     * @param sourceLocationUrl - The source location url. Required.
     * @param options - Additional request options contains downloadRecording api options.
     */
    async downloadStreaming(sourceLocationUrl, options = {}) {
        const result = this.contentDownloader.download(sourceLocationUrl, options);
        const recordingStream = (await result).readableStreamBody;
        if (recordingStream) {
            return recordingStream;
        }
        else {
            throw Error("failed to get stream");
        }
    }
    /**
     * Downloads a call recording file to the specified stream.
     * @param sourceLocationUrl - The source location url. Required.
     * @param destinationStream - The destination stream. Required.
     * @param options - Additional request options contains downloadRecording api options.
     */
    async downloadToStream(sourceLocationUrl, destinationStream, options = {}) {
        const result = this.contentDownloader.download(sourceLocationUrl, options);
        const recordingStream = (await result).readableStreamBody;
        if (recordingStream) {
            recordingStream.pipe(destinationStream);
            const finish = new Promise((resolve, reject) => {
                destinationStream.on("finish", resolve);
                destinationStream.on("error", reject);
            });
            await finish;
        }
        else {
            throw Error("failed to get stream");
        }
    }
    /**
     * Downloads a call recording file to the specified path.
     * @param sourceLocationUrl - The source location url. Required.
     * @param destinationPath - The destination path. Required.
     * @param options - Additional request options contains downloadRecording api options.
     */
    async downloadToPath(sourceLocationUrl, destinationPath, options = {}) {
        const result = this.contentDownloader.download(sourceLocationUrl, options);
        const recordingStream = (await result).readableStreamBody;
        if (recordingStream) {
            const writeFileStream = fs__namespace.createWriteStream(destinationPath);
            recordingStream.pipe(writeFileStream);
            const finish = new Promise((resolve, reject) => {
                writeFileStream.on("finish", resolve);
                writeFileStream.on("error", reject);
            });
            await finish;
        }
        else {
            throw Error("failed to get stream");
        }
    }
}

/**
 * Checks whether the type of a value is CallAutomationClientOptions or not.
 *
 * @param options - The value being checked.
 */
const isCallAutomationClientOptions = (options) => !!options && !coreAuth.isTokenCredential(options) && !communicationCommon.isKeyCredential(options);
/**
 * A CallAutomationClient represents a Client to the Azure Communication CallAutomation service.
 */
class CallAutomationClient {
    constructor(connectionStringOrUrl, credentialOrOptions, maybeOptions = {}) {
        const options = isCallAutomationClientOptions(credentialOrOptions)
            ? credentialOrOptions
            : maybeOptions;
        if (!(options === null || options === void 0 ? void 0 : options.userAgentOptions)) {
            options.userAgentOptions = {};
        }
        this.internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
            },
        });
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrUrl, credentialOrOptions);
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        this.credential = credential;
        this.callAutomationApiClient = new CallAutomationApiClient(url, this.internalPipelineOptions);
        this.callAutomationApiClient.pipeline.addPolicy(authPolicy);
        this.sourceIdentity = communicationUserIdentifierModelConverter(options.sourceIdentity);
    }
    /**
     * Initializes a new instance of CallConnection.
     * @param callConnectionId - The CallConnection id for the CallConnection instance. (ex: 421CONTOSO-cRD6-4RDc-a078-99dRANDOMf).
     */
    getCallConnection(callConnectionId) {
        return new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
    }
    /**
     * Initializes a new instance of CallRecording.
     */
    getCallRecording() {
        return new CallRecording(this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
    }
    /**
     * Get Source Identity that is used for create and answer call
     */
    getSourceIdentity() {
        return communicationUserIdentifierConverter(this.sourceIdentity);
    }
    async createCallInternal(request, options) {
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const _a = await this.callAutomationApiClient.createCall(request, optionsInternal), { callConnectionId, answeredBy, targets, sourceCallerIdNumber, source } = _a, result = tslib.__rest(_a, ["callConnectionId", "answeredBy", "targets", "sourceCallerIdNumber", "source"]);
        if (callConnectionId) {
            const callConnectionPropertiesDto = Object.assign(Object.assign({}, result), { callConnectionId: callConnectionId, source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((returnedTarget) => communicationIdentifierConverter(returnedTarget)), sourceCallerIdNumber: sourceCallerIdNumber
                    ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                    : undefined });
            const callConnection = new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
            const createCallResult = {
                callConnectionProperties: callConnectionPropertiesDto,
                callConnection: callConnection,
            };
            return createCallResult;
        }
        throw "callConnectionProperties / callConnectionId is missing in createCall result";
    }
    /**
     * Create an outgoing call from source to a target identity.
     * @param targetParticipant - A single target.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains createCallConnection api options.
     */
    async createCall(targetParticipant, callbackUrl, options = {}) {
        const request = {
            source: this.sourceIdentity,
            targets: [communicationIdentifierModelConverter(targetParticipant.targetParticipant)],
            callbackUri: callbackUrl,
            operationContext: options.operationContext,
            callIntelligenceOptions: options.callIntelligenceOptions,
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(targetParticipant.sourceCallIdNumber),
            sourceDisplayName: targetParticipant.sourceDisplayName,
        };
        return this.createCallInternal(request, options);
    }
    /**
     * Create an outgoing call from source to a group of targets identities.
     * @param targetParticipants - A group of targets identities.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains createCallConnection api options.
     */
    async createGroupCall(targetParticipants, callbackUrl, options = {}) {
        const request = {
            source: this.sourceIdentity,
            targets: targetParticipants.map((target) => communicationIdentifierModelConverter(target)),
            callbackUri: callbackUrl,
            operationContext: options.operationContext,
            callIntelligenceOptions: options.callIntelligenceOptions,
            sourceCallerIdNumber: PhoneNumberIdentifierModelConverter(options.sourceCallIdNumber),
            sourceDisplayName: options.sourceDisplayName,
        };
        return this.createCallInternal(request, options);
    }
    /**
     * Answer the call.
     * @param incomingCallContext - The context associated with the call.
     * @param callbackUrl - The callback url.
     * @param options - Additional request options contains answerCall api options.
     */
    async answerCall(incomingCallContext, callbackUrl, options = {}) {
        const { callIntelligenceOptions, operationContext } = options, operationOptions = tslib.__rest(options, ["callIntelligenceOptions", "operationContext"]);
        const request = {
            incomingCallContext,
            callIntelligenceOptions,
            operationContext,
            callbackUri: callbackUrl,
            answeredBy: this.sourceIdentity,
        };
        const optionsInternal = Object.assign(Object.assign({}, operationOptions), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        const _a = await this.callAutomationApiClient.answerCall(request, optionsInternal), { callConnectionId, targets, sourceCallerIdNumber, answeredBy, source } = _a, result = tslib.__rest(_a, ["callConnectionId", "targets", "sourceCallerIdNumber", "answeredBy", "source"]);
        if (callConnectionId) {
            const callConnectionProperties = Object.assign(Object.assign({}, result), { callConnectionId: callConnectionId, source: source ? communicationIdentifierConverter(source) : undefined, answeredby: communicationUserIdentifierConverter(answeredBy), targetParticipants: targets === null || targets === void 0 ? void 0 : targets.map((target) => communicationIdentifierConverter(target)), sourceCallerIdNumber: sourceCallerIdNumber
                    ? phoneNumberIdentifierConverter(sourceCallerIdNumber)
                    : undefined });
            const callConnection = new CallConnection(callConnectionId, this.callAutomationApiClient.endpoint, this.credential, this.internalPipelineOptions);
            const answerCallResult = {
                callConnectionProperties: callConnectionProperties,
                callConnection: callConnection,
            };
            return answerCallResult;
        }
        throw "callConnectionProperties / callConnectionId is missing in createCall result";
    }
    /**
     * Redirect the call.
     *
     * @param incomingCallContext - The context associated with the call.
     * @param targetParticipant - The target identity to redirect the call to.
     * @param options - Additional request options contains redirectCall api options.
     */
    async redirectCall(incomingCallContext, targetParticipant, options = {}) {
        const request = {
            incomingCallContext: incomingCallContext,
            target: communicationIdentifierModelConverter(targetParticipant.targetParticipant),
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        return this.callAutomationApiClient.redirectCall(request, optionsInternal);
    }
    /**
     * Reject the call.
     *
     * @param incomingCallContext - The context associated with the call.
     * @param options - Additional request options contains rejectCall api options.
     */
    async rejectCall(incomingCallContext, options = {}) {
        const request = {
            incomingCallContext: incomingCallContext,
            callRejectReason: options.callRejectReason,
        };
        const optionsInternal = Object.assign(Object.assign({}, options), { repeatabilityFirstSent: new Date(), repeatabilityRequestID: uuid.v4() });
        return this.callAutomationApiClient.rejectCall(request, optionsInternal);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const CloudEventMapper = {
    type: {
        name: "Composite",
        className: "CloudEvent",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String",
                },
            },
            data: {
                serializedName: "data",
                type: {
                    name: "any",
                },
            },
            dataBase64: {
                serializedName: "data_base64",
                type: {
                    name: "ByteArray",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String",
                },
            },
            time: {
                serializedName: "time",
                type: {
                    name: "DateTime",
                },
            },
            specversion: {
                serializedName: "specversion",
                required: true,
                type: {
                    name: "String",
                },
            },
            dataschema: {
                serializedName: "dataschema",
                type: {
                    name: "String",
                },
            },
            datacontenttype: {
                serializedName: "datacontenttype",
                type: {
                    name: "String",
                },
            },
            subject: {
                serializedName: "subject",
                type: {
                    name: "String",
                },
            },
        },
    },
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const serializer = coreClient.createSerializer();
/**
 * Helper function for parsing Acs callback events.
 */
function parseCallAutomationEvent(encodedEvents) {
    const decodedInput = parseAndWrap(encodedEvents);
    // parse cloudevent
    const deserialized = serializer.deserialize(CloudEventMapper, decodedInput, "");
    const data = deserialized.data;
    const eventType = deserialized.type;
    // get proper callbackevent and its parser
    let callbackEvent;
    let parsed = data;
    switch (eventType) {
        case "Microsoft.Communication.AddParticipantSucceeded":
            callbackEvent = { kind: "AddParticipantSucceeded" };
            parsed.participant = communicationIdentifierConverter(data.participant);
            break;
        case "Microsoft.Communication.AddParticipantFailed":
            callbackEvent = { kind: "AddParticipantFailed" };
            parsed.participant = communicationIdentifierConverter(data.participant);
            break;
        case "Microsoft.Communication.RemoveParticipantSucceeded":
            callbackEvent = { kind: "RemoveParticipantSucceeded" };
            parsed.participant = communicationIdentifierConverter(data.participant);
            break;
        case "Microsoft.Communication.RemoveParticipantFailed":
            callbackEvent = { kind: "RemoveParticipantFailed" };
            parsed.participant = communicationIdentifierConverter(data.participant);
            break;
        case "Microsoft.Communication.CallConnected":
            callbackEvent = { kind: "CallConnected" };
            break;
        case "Microsoft.Communication.CallDisconnected":
            callbackEvent = { kind: "CallDisconnected" };
            break;
        case "Microsoft.Communication.CallTransferAccepted":
            callbackEvent = { kind: "CallTransferAccepted" };
            break;
        case "Microsoft.Communication.CallTransferFailed":
            callbackEvent = { kind: "CallTransferFailed" };
            break;
        case "Microsoft.Communication.ParticipantsUpdated":
            callbackEvent = { kind: "ParticipantsUpdated" };
            parsed = participantsParserForEvent(data);
            break;
        case "Microsoft.Communication.RecordingStateChanged":
            callbackEvent = { kind: "RecordingStateChanged" };
            break;
        case "Microsoft.Communication.PlayCompleted":
            callbackEvent = { kind: "PlayCompleted" };
            break;
        case "Microsoft.Communication.PlayFailed":
            callbackEvent = { kind: "PlayFailed" };
            break;
        case "Microsoft.Communication.PlayCanceled":
            callbackEvent = { kind: "PlayCanceled" };
            break;
        case "Microsoft.Communication.RecognizeCompleted":
            callbackEvent = { kind: "RecognizeCompleted" };
            break;
        case "Microsoft.Communication.RecognizeCanceled":
            callbackEvent = { kind: "RecognizeCanceled" };
            break;
        case "Microsoft.Communication.RecognizeFailed":
            callbackEvent = { kind: "RecognizeFailed" };
            break;
        case "Microsoft.Communication.ContinuousDtmfRecognitionToneReceived":
            callbackEvent = {
                kind: "ContinuousDtmfRecognitionToneReceived",
            };
            break;
        case "Microsoft.Communication.ContinuousDtmfRecognitionToneFailed":
            callbackEvent = {
                kind: "ContinuousDtmfRecognitionToneFailed",
            };
            break;
        case "Microsoft.Communication.ContinuousDtmfRecognitionStopped":
            callbackEvent = {
                kind: "ContinuousDtmfRecognitionStopped",
            };
            break;
        case "Microsoft.Communication.SendDtmfTonesCompleted":
            callbackEvent = { kind: "SendDtmfTonesCompleted" };
            break;
        case "Microsoft.Communication.SendDtmfTonesFailed":
            callbackEvent = { kind: "SendDtmfTonesFailed" };
            break;
        case "Microsoft.Communication.CancelAddParticipantSucceeded":
            callbackEvent = { kind: "CancelAddParticipantSucceeded" };
            break;
        case "Microsoft.Communication.CancelAddParticipantFailed":
            callbackEvent = { kind: "CancelAddParticipantFailed" };
            break;
        default:
            throw new TypeError(`Unknown Call Automation Event type: ${eventType}`);
    }
    return Object.assign(Object.assign({}, parsed), callbackEvent);
}
function parseAndWrap(jsonStringOrObject) {
    if (typeof jsonStringOrObject === "string") {
        const o = JSON.parse(jsonStringOrObject);
        if (Array.isArray(o)) {
            if (o.length === 0) {
                throw Error("Empty event array.");
            }
            return o[0];
        }
        else {
            return o;
        }
    }
    if (Array.isArray(jsonStringOrObject)) {
        if (jsonStringOrObject.length === 0) {
            throw Error("Empty event array.");
        }
        return jsonStringOrObject[0];
    }
    else {
        return jsonStringOrObject;
    }
}
function participantsParserForEvent(data) {
    const { participants } = data, rest = tslib.__rest(data, ["participants"]);
    return Object.assign(Object.assign({}, rest), { participants: participants === null || participants === void 0 ? void 0 : participants.map((participant) => callParticipantConverter(participant)) });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** Defines values for VoiceKind that the service accepts. */
exports.VoiceKind = void 0;
(function (VoiceKind) {
    /** Male */
    VoiceKind["Male"] = "male";
    /** Female */
    VoiceKind["Female"] = "female";
})(exports.VoiceKind || (exports.VoiceKind = {}));
/** A Dtmf Tone. */
exports.DtmfTone = void 0;
(function (DtmfTone) {
    /** Zero */
    DtmfTone["Zero"] = "zero";
    /** One */
    DtmfTone["One"] = "one";
    /** Two */
    DtmfTone["Two"] = "two";
    /** Three */
    DtmfTone["Three"] = "three";
    /** Four */
    DtmfTone["Four"] = "four";
    /** Five */
    DtmfTone["Five"] = "five";
    /** Six */
    DtmfTone["Six"] = "six";
    /** Seven */
    DtmfTone["Seven"] = "seven";
    /** Eight */
    DtmfTone["Eight"] = "eight";
    /** Nine */
    DtmfTone["Nine"] = "nine";
    /** A */
    DtmfTone["A"] = "a";
    /** B */
    DtmfTone["B"] = "b";
    /** C */
    DtmfTone["C"] = "c";
    /** D */
    DtmfTone["D"] = "d";
    /** Pound */
    DtmfTone["Pound"] = "pound";
    /** Asterisk */
    DtmfTone["Asterisk"] = "asterisk";
})(exports.DtmfTone || (exports.DtmfTone = {}));
/** The type of the recognition that the service accepts. */
exports.RecognizeInputType = void 0;
(function (RecognizeInputType) {
    /** Dtmf */
    RecognizeInputType["Dtmf"] = "dtmf";
})(exports.RecognizeInputType || (exports.RecognizeInputType = {}));

exports.CallAutomationClient = CallAutomationClient;
exports.CallConnection = CallConnection;
exports.CallMedia = CallMedia;
exports.CallRecording = CallRecording;
exports.parseCallAutomationEvent = parseCallAutomationEvent;
//# sourceMappingURL=index.js.map
